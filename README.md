# Practical-Malware-Analysis
Write up for PMA labs solution

---

## CHAPTER 1
### Lab 1-1
#### Questions
1. Upload the files to http://www.VirusTotal.com/ and view the reports. Does
either file match any existing antivirus signatures?
2. When were these files compiled?
3. Are there any indications that either of these files is packed or obfuscated?
If so, what are these indicators?
4. Do any imports hint at what this malware does? If so, which imports
are they?
5. Are there any other files or host-based indicators that you could look for
on infected systems?
6. What network-based indicators could be used to find this malware on
infected machines?
7. What would you guess is the purpose of these files?
#### Solution
1- These files were written specifically for this book, so as of this writing,
you should not find a signature for them on VirusTotal.com. Of course, if
these files become part of the antivirus signatures as a result of the publi-
cation of this book, the results will be different.

2-Both files were compiled on December 19, 2010, within 1 minute of each other.
![dll](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/0640abd7-1014-4143-bcbd-8c1807e03a88)
![exe01](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/e83893ce-ef66-41fc-bc9f-3f7e8afb34e1)

3- There are no indications that either file is packed or obfuscated, PEiD labels this as unpacked code compiled with Microsoft Visual C++,
which tells us that these files are not packed.
![Unpackeddll](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/c30663f6-43f0-4fb2-96bc-696456578b0d)
![Unpackedexe01](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/2362d06b-7645-4fe6-8f77-d2f9001cfebe)

4- The interesting imports from Lab01-01.exe are FindFirstFile, FindNextFile,
and CopyFile. These imports tell us that the program searches the file-
system and copies files. The most interesting imports from Lab01-01.dll
are CreateProcess and Sleep. We also see that this file imports functions
from WS2_32.dll, which provides network functionality.
![exe01](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/ed8bfaac-8c8c-458c-a3c0-bcdc30a1ed7a)

5- Examine C:\Windows\System32\kerne132.dll for additional malicious activ-
ity. Note that the file kerne132.dll, with the number 1 instead of the letter
l, is meant to look like the system file kernel32.dll. This file can be used as
a host indicator to search for the malware.

6- The .dll file contains a reference to local IP address 127.26.152.13. This
address is an artifact of this program having been created for educational
and not malicious purposes. If this was real malware(and that is :') ), the IP address should
be routable, and it would be a good network-based indicator for use in
identifying this malware.

7- The .dll file is probably a backdoor because it imports functions
from WS2_32.dll, which provides network functionality and we also see two interest-
ing functions imported from kernel32.dll: CreateProcess and Sleep, which are
commonly used as backdoors. These functions are particularly interesting to
us in combination with the strings exec and sleep. The exec string is probably
sent over the network to command the backdoor to run a program with
CreateProcess. The sleep string is probably used to command the backdoor
program to sleep. The .exe file is used to install or run the DLL.
> [!NOTE]
> Hackers use backdoors to communicate with a command-and-control server and bypass security

> [!IMPORTANT]
> Backdoor -> Malicious code that installs itself onto a computer to allow the attacker access. Backdoors usually let the attacker connect to the computer with little or no authentication and execute commands on the local system.

![how_a_backdoor_attack_works-f](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/8ece181f-8d26-452b-bb76-99be989936c0)

---
### Lab 1-2
#### Questions
1. Upload the Lab01-02.exe file to http://www.VirusTotal.com/. Does it match
any existing antivirus definitions?
2. Are there any indications that this file is packed or obfuscated? If so,
what are these indicators? If the file is packed, unpack it if possible.
3. Do any imports hint at this program’s functionality? If so, which imports
are they and what do they tell you?
4. What host- or network-based indicators could be used to identify this
malware on infected machines?
#### Solution
1- The file matches 55 of 70 antivirus signatures.
![Virustotal](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/47419c31-aac3-4979-b189-38096aec5618)

2- Using Exeninfo, Detect it easy and PEiD, we should see that the file is packed with UPX if u have to unpack it download upx and run this command -> upx.exe -d filename.exe
Note : In Normal mode in PEid u see nothing but when u try Deep-Mode u will see that file is packed (:'
![Packed](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/d4fdfb1d-5dc0-4b0a-9266-2d2cf2a6c4bf)
![Deep-ModePEiD](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/9a1b2e1d-d2a4-44ca-b251-8a7d5eeda556)

3- After unpacking, we look at the imports sections and the strings. The
imports from kernel32.dll and msvcrt.dll are imported by nearly every program,
so they tell us little about this specific program. The imports from wininet.dll
tell us that this code connects to the Internet (InternetOpen and InternetOpenURL),
and the import from advapi32.dll (CreateService) tell us that the code creates a
service. When we look at the strings, we see www.malwareanalysisbook.com, which
is probably the URL opened by InternetOpenURL as well as by Malservice, which
could be the name of the service that is created.
![UnpackingFile](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/2128ac78-b00a-41d6-a0f8-e1f969c32a66)
![Strings](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/f8a4bbf9-7ef8-4018-af27-fab8312e06d2)

4- We can’t be sure what this program is doing, but we’ve found some indicators to help search for this malware across a network.

---
### Lab 1-3
#### Questions
1. Upload the Lab01-03.exe file to http://www.VirusTotal.com/. Does it match
any existing antivirus definitions?
2. Are there any indications that this file is packed or obfuscated? If so,
what are these indicators? If the file is packed, unpack it if possible.
3. Do any imports hint at this program’s functionality? If so, which imports
are they and what do they tell you?
4. What host- or network-based indicators could be used to identify this
malware on infected machines?
#### Solution
1- 61 of 71 virus engines identify this sample as malware.
![VirusTotal](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/37599913-63f3-4933-978b-cede707d9120)

2- The file is packed with (FSG 1.0), but we can’t unpack it at this time.
>[!NOTE]
>Not always ur tool will give u the exactly result ,so try using several tools as showen here Exeninfo couldn't recognize that the file is packed but other tools can recognize that.

![PackedFile](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/0a5fea37-a1de-46c5-927b-a3d01eef75c6)

3- This question can’t be answered without unpacking the file.

4- This question can’t be answered without unpacking the file.

---
### Lab 1-4
#### Questions
1. Upload the Lab01-04.exe file to http://www.VirusTotal.com/. Does it match
any existing antivirus definitions?
2. Are there any indications that this file is packed or obfuscated? If so,
what are these indicators? If the file is packed, unpack it if possible.
3. When was this program compiled?
4. Do any imports hint at this program’s functionality? If so, which imports
are they and what do they tell you?
5. What host- or network-based indicators could be used to identify this
malware on infected machines?
6. This file has one resource in the resource section. Use Resource Hacker
to examine that resource, and then use it to extract the resource. What
can you learn from the resource?
#### Solution
1-  59 of 71 antivirus engines identify this as malicious code that downloads and/or drops additional malware onto a system.
![VirusTotal,PNG](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/783b8e9e-21cc-47b2-94f6-bd9b41960466)

2- There are no indications that the file is packed or obfuscated.
![UnpackedFile](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/cb6fd92b-7330-4b08-b60d-4a99d6d4e200)

3- This program was compiled at Fri Aug 30 22:26:59 2019 | UTC, and this compile time is faked.
![CompilingTime](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/6979c6e2-d458-411b-a8ad-536d77feff87)

4- The imports from advapi32.dll indicate that the program is doing something with permissions. The imports from WinExec and WriteFile, along with the results from VirusTotal.com, tell us that the program writes a file to disk and then executes it. There are also imports for reading information from the resource section of the file.
![Imports](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/05901bd5-de42-476a-b87c-88144300b128)

5- The string \system32\wupdmgr.exe indicates that this program could create or modify a file at that location. The string www.malwareanalysisbook.com/updater.exe probably indicates where additional malware is stored, ready for download.
![Strings](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/a9bfa6d1-0671-4824-beda-0bad70d04d27)
![Strings1](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/7d4829ce-ae79-4d45-82f3-61ccfae83ab5)
![Strings2](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/dab6fc9a-f42f-4373-ad93-05736d0b4d43)

6- The resource section contains another PE executable. Use Resource
Hacker to save the resource as binary data, and then analyze the binary
file as you would analyze any executable. The executable in the resource
section is a downloader program that downloads additional malware, because it accesses the network functions. It calls
URLDownloadToFile, a function commonly used by malicious downloaders. It
also calls WinExec, which probably executes the downloaded file.
![BinFile](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/9dbe5bbc-40eb-4f50-8209-652fbdce63e9)

--------------------------------**This concludes CHAPTER 1**--------------------------------

---

## CHAPTER 5
### Lab 5-1
#### Questions
1. What is the address of DllMain?
2. Use the Imports window to browse to gethostbyname. Where is the import
located?
3. How many functions call gethostbyname?
4. Focusing on the call to gethostbyname located at 0x10001757, can you figure
out which DNS request will be made?
5. How many local variables has IDA Pro recognized for the subroutine at
0x10001656?
6. How many parameters has IDA Pro recognized for the subroutine at
0x10001656?
7. Use the Strings window to locate the string \cmd.exe /c in the disassembly.
Where is it located?
8. What is happening in the area of code that references \cmd.exe /c?
9. In the same area, at 0x100101C8, it looks like dword_1008E5C4 is a global
variable that helps decide which path to take. How does the malware set
dword_1008E5C4? (Hint: Use dword_1008E5C4’s cross-references.)
10. A few hundred lines into the subroutine at 0x1000FF58, a series of comparisons
use memcmp to compare strings. What happens if the string comparison
to robotwork is successful (when memcmp returns 0)?
11. What does the export PSLIST do?
12. Use the graph mode to graph the cross-references from sub_10004E79.
Which API functions could be called by entering this function? Based on
the API functions alone, what could you rename this function?
13. How many Windows API functions does DllMain call directly? How many
at a depth of 2?
14. At 0x10001358, there is a call to Sleep (an API function that takes one
parameter containing the number of milliseconds to sleep). Looking
backward through the code, how long will the program sleep if this code
executes?
15. At 0x10001701 is a call to socket. What are the three parameters?
16. Using the MSDN page for socket and the named symbolic constants functionality
in IDA Pro, can you make the parameters more meaningful?
What are the parameters after you apply changes?
17. Search for usage of the in instruction (opcode 0xED). This instruction is
used with a magic string VMXh to perform VMware detection. Is that in use
in this malware? Using the cross-references to the function that executes
the in instruction, is there further evidence of VMware detection?
18. Jump your cursor to 0x1001D988. What do you find?
19. If you have the IDA Python plug-in installed (included with the commercial
version of IDA Pro), run Lab05-01.py, an IDA Pro Python script
provided with the malware for this book. (Make sure the cursor is at
0x1001D988.) What happens after you run the script?
20. With the cursor in the same location, how do you turn this data into a
single ASCII string?
21. Open the script with a text editor. How does it work?
#### Solution
1- DLLMain is found at 0x1000D02E in .text section.
![13](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/350f10c8-9091-4439-87be-1a5cc0182585)

2- gethostbyname is found at 0x100163CC in .idata section.
![gethostbyname_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/077e06d7-dfd6-4ed9-869c-70febc0abfde)

3- gethostbyname is called 9 times by 5 different functions
throughout the malware.(go to gethostbyname function and press x to get xRefs to this func.)(The text “Line 1 of 18” at the bottom
of the window tells us that there are nine cross-references for gethostbyname.
Some versions of IDA Pro double-count cross-references: p is a reference
because it is being called, and r is a reference because it is a “read” reference
(since it is call dword ptr [...] for an import, the CPU must read the import
and then call into it))
![gethostbyname](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/9ed6d696-3c7d-4719-a1ce-e1a246b2c8cd)

4- A DNS request for pics.practicalmalwareanalysis.com will be made by the
malware if the call to gethostbyname at 0x10001757 succeeds.
(press G to quickly navigate to 0x10001757, start following z code, it seems like gethostbyname function takes a single parameter so u have to figure out what is in EAX,  It appears that off_10019040
is moved into EAX. If we double-click that offset, we see the string [This is
RDO]pics.practicalmalwareanalysis.com), and if we adding 0xD to EAX the pointer to location of URL will be like this in figure gethostbynameDNS.PNG)
![Screenshot06](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/fc66db85-75a4-4b49-816a-8555e6dbc987)
![gethostbynameDNS](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/c1138548-cc1a-44b4-a1e1-43e811271ffc)
![Screenshot07](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/042b97ab-4c73-40fa-831e-08791be48acb)

5- 23 local variables (local variables correspond to negative offsets)
just press G to navigate to 0x10001656, Simple friend :"
![Screenshot08](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/21610934-fa65-49a7-ab3f-bf4b0c1d6067)

6- There is onle one parameter labeled -> lpThreadParameter(The parameters correspond to positive offsets)

7- The string resides in xdoors_d section at 0x10095B34

8- That area of code appears to be creating a remote shell session for the attacker. 
By following the xref to the subroutine which references \cmd.exe /c
This function shows a series of memcmp functions that are comparing strings such as cd, exit, install, inject, and uptime.
We’re able scroll through the function to see a number of interesting values being pushed to the stack, in this case the values: quit, exit, and cd catch our eyes.
Continuing on we can see entries such as: idle, uptime, mmodule, minstall, and inject all catch out eyes.
Finally if we look around this function we can find that the char array aHiMasterDDDDDD mentioning a ‘Remote Shell Session’, and ass such we can infer we’re looking at a remote shell session function.
![8](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/5d858127-2e93-494e-9f06-8939430d2377)
![8_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/474205ae-504d-47a7-a752-07f2b3ba35de)
![8__](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/f21474de-b2e9-4d76-987f-6d5cbe18dddc)
![8___](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/1ff1b9ff-5c24-401d-a5ab-b153b127878e)
![8____](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/8a5f45b6-5131-4cab-9cb7-8428306cbe0a)


9- The OS version is stored in the global variable dword_1008E5C4.
Starting at address 0x100101C8 we can see a comparison statement comparing ebx to dword_1008E5C4, and viewing the cross-references to this we can find one of them which actually contain the mov statement to set the value.
Following this we can see that the output of sub_10003695 will be moved directly into dword_1008E5C4.
So by looking into this routine we can find that it is comparing the dw platform ID to the value ‘2’:
By running some searches based on this we find the following documentation on PlatformID
This tells us that the field 2 indicates the operating system is Windows NT or later.
![9](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/36d2b4c1-97d0-418b-b718-92b2d2b92bcf)
![9_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/df16ff45-f4af-4448-90fc-0020b809b5a1)
![9__](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/142aac72-a039-45c4-acae-ccb6e96e38c2)
![9___](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/62371c6a-8f5a-4e16-b8e3-189444622f5f)


10- The registry values located at HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WorkTime and WorkTimes are queried and sent over a network socket.
Looking into this routine we can find the entry comparing “robotwork” which uses a JNZ branch.
Because of this the jnz is NOT taken, and we end up running a call to the subroutine sub_100052A2, so let’s take a look into it.
From this we can see that it is opening a registry key at: HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion, in this case jz statement checks if the registry was successfully opened or not.
Zero flag IS set, so let’s follow loc_10005309.
Here we can see it is querying WorkTime, and WorkTime registry keys. If we look back at where this opened the registry key we can see that it is passing an argument type of “Socket” with the value ‘s’. Looking back at the start of this question we can see that this pushes ebp+s which indicates this information is sent back over the passed network socket.
![10](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/acd9222b-36fe-44e6-b372-56fc25790ee5)
![10_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/7c1e5060-6e4d-438d-b1e2-04c26dc6d565)
![10__](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/aff9dc2a-2cba-456a-886c-f7023f9096d4)
![10___](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/baa26bb8-c0da-45db-829d-8c74cd463dd2)

11- By looking into the exports within this DLL we can find PSLIST. Following this and pressing SPACE leads us to the IDA Graph view.
From here we can see that one of 2 paths will be taken depending on the result of sub_100036C3, so let’s dive a bit deeper there.
we can see this is checking whether the operating system is Windows NT or later;
then checking if it’s major version is 5. So let’s look at what this represents by looking at the documentation on OSVERSIONINFOEXW structure.
So we now know it is checking whether the OS is any of these versions. Depending on the output it will either run sub_10006518 or sub_1000664C.
Taking a closer look at sub_10006518 we can see based on the API call to CreateToolhelp32Snapshot, strings, and the function name that this will allow them to grab a process listing.
Looking further at sub_1000664C, we can see that this performs the same type of calls as sub_10006518; however, this also sends through reference to the socket to send the output back to.
Both code paths return the process listing over the socket using send.
![11](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/0c0e5ba9-7eb4-49f8-8df2-d1dc77a182ea)
![11_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/d282cdb6-af93-40e2-8823-391785d3cf87)
![11_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/2fde1d19-bef9-4e0c-b06c-05606ebe9ae4)
![11__](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/863758ec-bf74-4c2b-8aea-7927839fc6f4)
![11___](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/fb8d0d15-5783-46aa-8afd-8ba6cfe0f351)
![11____](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/afcb3b2b-bf89-43e6-be80-8bbf10864c3c)
![11_____](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/f18cf8d7-5b7f-4665-bc9e-f8056b0c9a09)

12- GetSystemDefaultLangID, send, and sprintf are API calls made from sub_10004E79. This function could be renamed to something useful like GetSystemLanguage.
press G to go to address 0x10004E79 and then view xRefs from this function.
![12](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/40ed5171-ef93-48fc-b651-5cc814442136)

13- By clicking View > Graphs > User xrefs chart, and then adjusting the settings to start and end at the function DLLMain with a depth of 1, we’re able to see 4 Windows API Functions.
If we expand this to a depth of 2, the chart blows out in size and we’re looking at 33 including duplicates.
![13](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/b41b90a4-db9c-404d-9b32-42e6b171a426)
![13_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/5a5a161f-7840-4020-b95e-f5a6977e91a4)
![13__](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/e80a1cb9-7c67-4188-be98-5c727ad07cd8)
![13___](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/07230168-b2c2-426a-83ce-14427454f171)

14- Moving back from the call to sleep, we can see that EAX is multiplied by 1000 before being pushed to the stack and called. This matches the reference to milliseconds, in that there are 1000 milliseconds in a second.
If we follow the previous routine at offset 10019020 (off_10019020), we see it points to the data [This is CTI]30 .
Looking back at the commands  it is then adding 0Dh (13) to EAX which moves the pointer past the text ‘[This is CTI]’ leaving only ‘30’.
Based on the call to atoi this is then converted to a number before being multiplied by 1000 and as such the program will sleep for 30 seconds if this executes.
![14](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/fd0bbffa-6d82-482b-8174-53a3f9b0c397)
![14_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/508d13ec-ed24-4de6-a302-9f78818fcabd)
![14__](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/1b41a105-9b1f-45d8-a4c6-33d3d48b1279)

15- Looking at this address we can see a call to socket which takes 3 parameters (protocol, type, and af) all of which are pushed to the stack prior to the call.
![15](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/df693ea3-0769-4d02-98f7-9203d3e92c82)

16- By looking into the MSDN Socket Function we can find what these numbers correlate to.
y right clicking and selecting Use Standard Symbolic Constant, we’re able to quickly change these to accurately reflect their assigned values.
![16](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/4dcfee31-a970-49ff-a7ad-85183e78a769)
![16_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/4ecba8a1-fad6-4f39-b762-e0c69b21bd8f)
![16___](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/34a048bd-3751-4235-8be0-eaf6ed045832)
![16____](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/4ca19119-6756-4334-bebb-20a4a9605a15)

17- By searching for ‘ED’ as a sequence of bytes (ALT+B) we can find only one occurrence of the instruction ‘in’
Diving into this function we can see it is checking for the value VMXh which indicates this malware is implementing a known anti VM technique.
Looking at the Xrefs to this function we can see a reference to locating a VM in use and cancelling installation.
![17](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/88872aac-1752-44c0-a9e9-693c53314929)
![17_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/96d99c76-e93d-4ab9-8218-2b28bf0afb12)
![17__](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/c2b40cff-843d-4a73-895b-0f673e47c31f)

18- If we jump here using ‘G’ we find a bunch of seemingly random data.
![18](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/8270bf3d-0106-4b20-94ea-22c983bbfabf)

19- From this we can see it will loop through from our current position (0x1001D988) up to 50 bytes and run an XOR command over all of them by 0x55. From this we can infer that the script will de-obfuscate the seemingly random data.
![19](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/91300ee3-4346-40ed-88e5-2735096c9df1)

20- This can be done by pressing A on the string, we wind up with gibberish still because each element still requires the XOR function.
We can also see there’s been some overlap of hex indicated by the ,27h,’ elements. By removing these and running the XOR command over all of the strings concatenated using CyberChef(https://gchq.github.io/CyberChef/) we get a hidden message.
![20](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/9f21fab6-b4e0-4ea0-9c5c-7a40b291ae6a)
![20_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/182f2ec7-0339-4ba0-8a71-d4133a0ac8d4)

21- In this instance we can see that there’s been some issues bringing back any capitalisation somewhere along the line and this should read “xdoor is this backdoor, string decoded for Practical Malware Analysis Lab :)1234”. This is yet another benefit of us running this through the python script; however, the purpose still stands based on how the python script works. It will loop through from our position (0x1001D988) up to 50 bytes and run an XOR command over all of the values individually by 0x55

--------------------------------**This concludes CHAPTER 5**--------------------------------

---

## CHAPTER 6
### Lab 6-1
#### Questions
1. What is the major code construct found in the only subroutine called by main?
2. What is the subroutine located at 0x40105F?
3. What is the purpose of this program?

#### Solution
1- if statement located at 0x401000.
by starting at the main func. we see call    sub_401000, moving into it there is a compare statement before JZ jump, from this and graph view we can recognize that it's (if) code construct.
![Capture](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/5590a200-4d80-458e-90a0-3bcb86081f98)

2- By looking at the values that pushed into the stack, we can say that it's (printf) function.
![Capture0](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/c4d852bc-cf9c-454f-87b1-2750fd60d354)
![Capture1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/59115a17-70dc-49da-ab6b-3dbcc6872474)

3- This program checks internet connection and responds with 1 or 0 based on your cennection.

---

### Lab 6-2
#### Questions
1. What operation does the first subroutine called by main perform?
2. What is the subroutine located at 0x40117F?
3. What does the second subroutine called by main do?
4. What type of code construct is used in this subroutine?
5. Are there any network-based indicators for this program?
6. What is the purpose of this malware?

#### Solution
1- By looking at the main func. we can see that it calls sub_401000, diving into this function we can see that it gets internet connection state and responds with 1 if connects otherwise 0.
![Capture](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/5d288997-822d-4b51-bc13-93ee760961cf)
![Capture0](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/de4afa8c-41fd-4627-b500-5a51bc525fce)

2- Taking a look at Xrefs to this subroutine we can see that it' called by main func. and before calling this subroutine there are 2 parameters are pushed into the stack, first is string ("Success: Parsed command is %c\n") and the second is var_8 returned from the previous call at 0x401148. so we can deduce that printf is the subroutine located at 0x40117F.
![Capture1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/2ccf686f-ad78-4cbf-a5fe-39413eca51f0)

3- By looking at sub401040 we can see that this attempts to open the URL http://www.practicalmalwareanalysis.com/cc.htm and if it is successful, it will read in the first 0x200 (512) bytes into a buffer.
![Capture2](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/c7d17090-0c8e-4dbd-aea7-a72d39ec04d6)
![Capture3](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/8835a430-d6ef-478d-a067-3bac8ff303b2)

4- After looking at func. we can wee 2 different pathways, one where it is able to read HTML file and the other if it failed.
Diving into code where it successfully read the HTML file, we can see multiple compare statements based on 4 characters from the buffer "<!--" and we know that it's a start of a comment.
![Capture5](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/df8a2bdb-05cd-4697-a0e4-9e5fda079a0d)

5- There are two network-based indicators. The program uses the HTTP User-Agent Internet Explorer 7.5/pma and downloads the web page located at: http://www.practicalmalwareanalysis.com/cc.htm (URL to be opened).

6- The purpose of this malware is to check if there is an active internet connection, if there is it will proceed to try and open the URL http://www.practicalmalwareanalysis.com/cc.htm using the User-Agent ‘Internet Explorer 7.5/pma’ and if it is successful, it will read in the first 0x200 (512) bytes into a buffer, if not it will terminate. From this buffer the characters ‘<!–’ are read, and if they don’t exists the error message “Error 2.3: Fail to get command\n” is printed.
if these do exist, it will print the message “Success: Parsed command is %c\n”, where %c is the character read from the HTML comment buffer. We can also see this will wait 60000 milliseconds (1 minute) before terminating.
![Capture6](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/c97bcad2-7350-46ed-8871-a1dcfe7dafec)

---

### Lab 6-3
#### Questions
1. Compare the calls in main to Lab 6-2’s main method. What is the new
function called from main?
2. What parameters does this new function take?
3. What major code construct does this function contain?
4. What can this function do?
5. Are there any host-based indicators for this malware?
6. What is the purpose of this malware?

#### Solution
1- The new function called is sub_401130.
![Capture](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/f1c6cfdf-0f9c-44be-a2dd-f08fb6e0e5e3)

2- It takes 2 parameters char and LPCSTR(Long Pointer Constant String) lpExistingFileName.
There are 2 items are pushed (argv, var_8).
in this instance argv represents argv[0] which points to the name of the program, we can see that var_8 is set to AL at 0x401228. this means that the lower 8 bits(char in this case ) from sub_401040 becomes var_8, and we knew that sub_401040 allocates bytes to a buffer and then checks for "<!--", depending on what we knew we can say that the next byte (char) after "<!--" is that byte being passed to the function.
![Capture0](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/652c435f-b911-46d6-9a71-cc0286eb7643)
![Capture1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/2515517b-b0d7-4c8c-ae5b-f06ef0f9e61f)

3- Switch statement with a Jump Table.
![Capture2](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/8047c624-011a-4a9b-b46b-c841482f4782)

4- The function subtracts 'a' from whatever passed to it, if it's 'a' it will have value 0, b value 1, c value 2 and so forth...
In the case of this function, depending on the letter you send it (after ‘<!–-’ in the HTML), between ‘a’ and ‘e’, it will run a different set of commands.
If cmp instruction more than 4 it will jump to the default case
jmp multiplied by 4 as each adddress is 4 bytes long.
Taking a look at the cases :
- 'a' (97 ASCII)-> The program creates a directory at "C:\\Temp"
- 'b' (98 ASCII)-> The program copies lpExistingFileName(the program name) into "C:\\Temp\\cc.exe"
- 'c' (99 ASCII)-> The program deletes the file located in this path "C:\\Temp\\cc.exe"
- 'd' (100 ASCII) -> The program sets a value "Malware" in the windows registery for presistence, it sets Software\Microsoft\Windows\CurrentVersion\Run\Malware to C:\Temp\cc.exe, which makes the malware starts at the system boot.
- 'e' (101 ASCII) -> The program Sleeps for 100,000 milliseconds (100 seconds)
- Finally, the default case -> Display the error message “Error 3.2: Not a valid command provided”
![Capture3](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/5b35f8fd-f6a9-4f2f-a0bf-61a729955f72)
![Capture4](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/2dc90543-5fc1-42c4-a072-01a5e2c858db)
![Capture5](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/5dd1303c-fad8-45e0-bff6-dac33a0ba967)

5- The host based indicators from this are the file the malware will copy itself to, and the registry key used for persistence.
Note: A quick search reveals that 80000002h which is pushed to the stack in the registry key is linked to HKEY_LOCAL_MACHINE, so we can assume it will be here rather than the users registry hive.
C:\Temp\cc.exe
HKLM\Software\Microsoft\Windows\CurrentVersion\Run /v Malware

6- The purpose of this malware is to check if there is an active internet connection, if there is it will proceed to try and open the URL http://www.practicalmalwareanalysis.com/cc.htm using the User-Agent ‘Internet Explorer 7.5/pma’ and if it is successful, it will read in the first 0x200 (512) bytes into a buffer, if not it will terminate. From this buffer the characters ‘<!–’ are read, and if they don’t exists the error message “Error 2.3: Fail to get command\n” is printed. If these do exist, it will print the message “Success: Parsed command is %c\n”, where %c is the first character read from the HTML comment buffer.
Based on the parsed command between the letters a and e, the program will either:

Create a directory at C:\Temp if it doesn’t exist
Copy a file to C:\Temp\cc.exe, the file passed is lpExistingFileName which we know would be the program name
Delete the file located at C:\Temp\cc.exe if it exists
Create persistence using the subkey HKLM\Software\Microsoft\Windows\CurrentVersion\Run with the value ‘Malware’ pointing to C:\Temp\cc.exe
Sleep for 100,000 milliseconds (100 seconds)
Display the error message “Error 3.2: Not a valid command provided”

---

### Lab 6-4
#### Questions
1. What is the difference between the calls made from the main method in
Labs 6-3 and 6-4?
2. What new code construct has been added to main?
3. What is the difference between this lab’s parse HTML function and
those of the previous labs?
4. How long will this program run? (Assume that it is connected to the
Internet.)
5. Are there any new network-based indicators for this malware?
6. What is the purpose of this malware?

#### Solution
1- In Lab 6-3 the calls directly from the main method consist of:
sub_401000, sub_401040, sub_401271, sub_401130, Sleep
In Lab 6-4 the calls directly from the main method consist of:
sub_401000, sub_401040, sub_401150 (differs), sub_4012B5 (differs), Sleep
sub_401000 = Check for internet connection.
sub_401040 = HTML C2 parsing function. Note: in 06-04 the User-Agent has changed.
sub_401150 (differs) = Jump Table switch statement as previously identified in Lab 06-03 sub_401130 to control actions.
sub_4012B5 (differs) = printf as previously identified in Lab 06-03 sub_401271.
![Screenshot01](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/2865d01c-b135-411c-9afc-6a09bc50f726)
![Screenshot02](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/6654695d-40e1-4867-9078-bc509bc82452)
![Screenshot03](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/a414298d-b4a4-413b-8599-d5def9ab7ca2)
![Screenshot04](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/73a455b8-d9af-47f9-b2a6-9661bb0502e2)
![Screenshot05](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/c286943c-3514-43eb-9e42-a55133993c91)

2- It's for loop function that increaments a variable by 1 a time and will be compared against the value 5A0h in hex (1440).
![Screenshot06](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/08896454-4595-4b6e-8ab3-24700d149053)

3- It takes an argument as apparent with the reference to arg_0, and a new variable szAgent and szAgent is being populated with the formatted user agent value.
![Screenshot08](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/d70fc842-c923-4d8c-9998-0a589ec22b31)

4- The program will run for 1440 minutes (24 hours).
1440 * 60,000 milliseconds = 86,400,000 milliseconds.

5- Internet Explorer 7.50/pma%d
where %d is equivalent to var_C or in this case the number of minutes that have passed since the program started. This can be used to monitor how long it has been running for in each request.

6- The purpose of this malware is to check if there is an active internet connection, if there is it will proceed to try and open the URL http://www.practicalmalwareanalysis.com/cc.htm using the User-Agent ‘Internet Explorer 7.5/pma%d’ which is passed in from a looping incremental user variable (this is used to track how long the program has been running.
If it is successful, it will read in the first 0x200 (512) bytes into a buffer, if not it will terminate. From this buffer the characters ‘<!–’ are read, and if they don’t exists the error message “Error 2.3: Fail to get command\n” is printed.
If these do exist, it will print the message “Success: Parsed command is %c\n”, where %c is the first character read from the HTML comment buffer.

Based on the parsed command between the letters a and e, the program will either:

- 'a' -> Create a directory at C:\Temp if it doesn’t exist.
- 'b' -> Copy a file to C:\Temp\cc.exe, the file passed is lpExistingFileName which we know would be the program name.
- 'c' -> Delete the file located at C:\Temp\cc.exe if it exists.
- 'd' -> Create persistence using the subkey HKLM\Software\Microsoft\Windows\CurrentVersion\Run with the value ‘Malware’ pointing to C:\Temp\cc.exe.
- 'e' -> Sleep for 100,000 milliseconds (100 seconds).
- Finally, default case -> Display the error message “Error 3.2: Not a valid command provided”

Based on the incrementing variable this program will run for 24hours before terminating. By renaming these functions and viewing the main method flow chart, we can easily see the flow of this malware.

--------------------------------**This concludes CHAPTER 6**--------------------------------
## CHAPTER 7
### Lab 7-1
#### Questions
1. How does this program ensure that it continues running (achieves persistence)
when the computer is restarted?
2. Why does this program use a mutex?
3. What is a good host-based signature to use for detecting this program?
4. What is a good network-based signature for detecting this malware?
5. What is the purpose of this program?
6. When will this program finish executing?

#### Solution
1- By examining the main function of this program, we can see reference to a service name 'MalService', a call to the StartServiceCtrlDispatcherA(According to the MSDN documentation, this function is used by a program to implement a service)
within this sub_401040(which will be called after the call of StartServiceCtrlDispatcherA) we can see references to opening the Service Control Manager(SC Manager) and evidence of a service creation which will be used for persistence.
NOTE (May be useful):
There are various methods that malware can use to achieve persistence, such as modifying the registry, creating scheduled tasks, installing itself as a service, or using rootkits to hide its presence.
By using these methods, malware can ensure that it runs automatically when the system starts, runs periodically or runs constantly in the background.
Malware achieves persistence by modifying the registry keys in one of AutoStart Extention Points (ASEPs), There  are some of the registry keys that malware mostly achieves its persistence by editing the registry keys at the User Level:
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce
If the malware is able to gain admin privileges, it will infect some of the keys at admin/system-level privileges:
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
![1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/e7af99bd-efe3-4533-aa68-dc6c29cd59fc)
![1_](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/85ebcbcd-eff0-40fa-a4de-cb4319698ff8)

---

2- The program uses Mutex to ensure that only one copy of the program is running at a time.
Detailed Answer:
By calling sub_401040, we cann see that it calls the function OpenMutexA and this call is attempting to obtain a handle to the named mutex 'HGL345', If the call fails the program terminates, else it will create a Mutex with this name.
![2](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/aaeb57d9-85c8-4ce9-8bb9-4a7493421012)
![2_](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/25272b01-6732-4374-90f6-bb43756bd153)

---

3- Detection of this program can be done by checking any host for the hardcoded mutex ‘HGL345’ or by checking them for any service with the hardcoded name ‘MalService’

4- BY examining the looping function, we can see that it uses the User Agent "Internet Explorer 8.0" and communicates with the URL "http://www.malwareanalysisbook.com" which are network-based indicators which can be used to identify execution of this program.
![4](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/6fa7ebad-c588-47de-8a0b-57506587dcc6)

---

5- After creating a service for persistence, we can see that the program sets up a timer checking for when the year is (0x834h) 2100 in decimal or midnight on january 1st 2100, At this time it will create (0x14h) 20 threads and executed the subroutine pointed at StartAddress and this routine opens the URL http://www.malwareanalysisbook.com whichh leads us to beleive that this is DDoS program, which when multiple machines have this setup will cause a DDoS againist http://www.malwareanalysisbook.com.
![5](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/88cc05cd-0ca4-4f42-a215-c06c48d55f8a)
![5_](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/3c43d2f3-2ef1-46b4-b677-ef5549015198)
![5__](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/41ead1ae-8885-40a3-a231-2b03c0388449)

---

6- This program will never finish. It waits on a timer until 1st january 2100, and then creates 20 threads, each of which runs in an infinite loop and download www.malwareanalysisbook.com indefinitely.
![6](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/e11376cf-25c4-45ed-b538-f6f6918c35b9)

---

In summary, this malware uses mutexes to ensure that only one copy is running at a time, creates a service to ensure that it runs again when the system reboots, waits until January 1, 2100, and then continues to download www.malwareanalysisbook.com indefinitely.

---

### Lab 7-2
#### Questions
1. How does this program achieve persistence?
2. What is the purpose of this program?
3. When will this program finish executing?

#### Solution
1- When examining the program it shows no evidence or strings relating to creation of common persistence mechanisms such as run keys, scheduled tasks, services, or startup files. so, The program does not achieve persistence.
![1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/0f967e34-f3f0-4807-ac36-163f8cd9f5ad)

---

2- Taking a look at the program imports we can see COM-related functions such as CoCreateInstance and OleInitialize functions which are required in order to use COM functionality.
Next, we can try dynamic analysis by running the program, it opens Internet Explorer and displays an advertisement. so, There is no evidence of the program modifying the system or installing itself to execute when the computer is restarted.
Lets navigate to the Main method and take a look at the code:
The malware initializes COM and obtain a pointer to a COM object with OleInitialize at 0x401005 and CoCreateInstance at 0x401022, the COM object returned will be stored in ppv.
Now we nned to examine the InterfaceIdentifier(IID) and ClassIdentifier(CLSID) to determine what COM functionality is being used.
rclsid=0002DF01-0000-0000-C000-000000000046
riid=D30C1661-CDAF-11D0-8A3E-00C04FC9E26E
To determine which program will be called, we can check the registry for CLSID or search for the IID on the internet for any documentation, After searching we can see that the IID is for IWebBrowser2 and CLSID is for InternetExplorer.
Following the code we can see that EAX points to the location of the COM object then EDX points to the beginning of the COM object itself and the function at an offset of +0x2C from the object is called, and the offset 0x2C for the IWebBrowser2 interface is the Navigate function.
When Navigate is called, Internet Explorer navigates to the web address http://www.malwareanalysisbook.com/ad.html.
After the call to Navigate, there are a few cleanup functions and then the program ends.
![2](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/1aa47ff8-25da-40ea-8fd1-641e1281759c)
![2_](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/556f96d0-7a46-4424-a767-bd5c10362e07)
![2__](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/d29dfd02-7bc1-4a94-8db9-e0df269fc360)

---

3- It simply displays a one-time advertisement and ends.

---

### Lab 7-3
#### Questions
1. How does this program achieve persistence to ensure that it continues
running when the computer is restarted?
2. What are two good host-based signatures for this malware?
3. What is the purpose of this program?
4. How could you remove this malware once it is installed?

#### Solution
1- The program shows refernce to DLL and a Windows DLL of kernel32.dll,
![1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/c678261e-e716-4932-afde-1486ed234b57)

By examining the rest of the application we can see a different DLL named kerne132.dll and reference to the supplied Lab07-03.dll DLL being copied into a file named C:\Windows\System32
![1_](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/7fdf5746-46e1-4956-9425-960903287c73)

By looking inside the function call to sub_4011E0, within this we can see a statement that indicates files are being checked within C:\* which was passed to the program, By searching further within this function, we can see that a comparison occurs that checks if a file is a .exe, and if not a jump occurs.
![1__](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/c875e749-f488-4ae5-bed9-0437a1fa02a1)
![1___](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/3e17c683-6923-4f23-a1ab-fdcb4b1b0c5b)
![1____](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/59b44da4-5fdb-4565-b8ca-b4acfbd8e445)

Based on this we can infer that something the file system located at C:\ is being recursively checked for .exe files, and if one is found something occurs. By checking the function sub_4010A0 which runs if the jump is not performed, we can gather what occurs when an executable file is found. 3 key calls we find are CreateFile, CreateFileMapping, and MapViewOfFile. Based on this we can infer that exe file is mapped into memory and then can be modified by this program.
![1_____](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/17708791-b42c-4bf5-836b-d6288f91b9ce)

Looking further at the program we can see that it compares kernel32.dll to a location within the executable, and if it isnt found, it will jump and repeat the process. Where it is found it proceeds to copy a value referenced by dword_403010 over the top of it.
With this we can infer that the program searches for executables recursively within C:\, and when they’re found it will open them, and directly in memory modify the file to replace any instances of kernel32.dll with kerne132.dll for persistence. Based on this we can infer the program is a type of file infector and uses the copied kerne132.dll (Lab07-03.dll) for its main payload. A brief look into Lab07-03.dll confirms that this has some form of C2 function and is likely a malicious as i explained below in details.
![1______](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/2d537b98-95cc-4f75-ba4f-e6f494e301f7)
![1_______](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/b6d9fe90-5811-4252-b15f-5d784c7cfe2e)

---

Detailed Answer:
There are many interesting strings in exe file we can show them in Die or using strings command in cmd, we can see kerne132.dll, .exe, WARNING_THIS_WILL_DESTROY_YOUR_MACHINE, C:\Windows\System32\Kernel32.dll, C:\windows\system32\kerne132.dll, Kernel32., Lab07-03.dll and C:\*
The string kerne132.dll is clearly designed to look like kernel32.dll but replaces the l with a 1.
The string Lab07-03.dll tells us that the .exe may access the DLL for this lab in some way.
![1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/89048ae4-1c1a-4c9c-99e1-519ced98bdca)

Lets examine the imports for Lab07-03.exe
The imports CreateFileA, CreateFileMappingA, and MapViewOfFile tell us that this program probably opens a file and maps it into memory. The FindFirstFileA and FindNextFileA combination tells us that the program probably searches directories and uses CopyFileA to copy files that it finds.
And the exe does not import Lab07-03.dll (or use any of thefunctions from the DLL) This behavior is suspect :"
![1_](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/de94efe7-8686-4549-9ddc-f4a897d3d4ff)

Taking a look at DLL for any interesting strings and imports and i found a few strings hello, 127.26.152.13(IPAddress), sleep and exec.
The most interesting string is an IP address, 127.26.152.13, that the malware might connect to.
![1__](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/7ebb3047-55d6-4206-b6b7-8543ae051912)

Looking at the imports of this DLL file we can see that the imports from ws2_32.dll contain all the functions necessary to send and receive data over a network. Also CreateProcess function, which tells us that this program may create another process.
![1___](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/eb5ec372-ae17-4bff-a5ab-efbdfff918d2)

Lets look at exports of DLL. Oddly, it has no exports !!
Now we can move to dynamic analysis, When running the executable, it exits quickly without much noticeable activity.
We could try to run DLL using rundll32 but because the DLL has no exports, that won’t work.
Unfortunately, basic dynamic analysis doesn’t tell us much, So lets perform analysis using IDA Pro.
Strarting with DLL because it's analyzing will be much easier than EXE file:
Lets look at the imports to get a quick view of the DLL’s functionality.
The call to library function malloc which allocates memory blocks.Following this are calls to OpenMutexA and CreateMutexA to ensure that only one copy of the malware is running at one time.
The other listed functions are needed to establish a connection with a remote socket, and to transmit and receive data. This function ends with calls to Sleep and CreateProcessA.
Now, we don’t know what data is sent or received or what process is being created but we can guess that the function that sends and receives data and creates processes is designed to receive command from a remote machine.
At this moment we need to know what data is being sent and received, checking the destination address of the connection, Before the connect call there is a call to inet_addr with fixed IPAddress 127.26.152.13 and port 0x50 which is port 80 that used for web traffic.
![1____](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/a4968789-0d3b-4c93-958b-deb3c74d721d)

Lets take a look at send function to see what data is being communicated, buf stores the data to be sent over the network and it represents the string "hello".
![1_____](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/99abc1b8-5037-4cc7-97a4-7f7d601b01cc)

Lets search to know what the command line is, our receive buffer starts at 0x1000 and command line at 0x0FFB, this is 5 bytes into our receive buffer, In this case, the data received from the remote server would be exec FullPathOfProgramToRun. When the malware receives the exec FullPathOfProgramToRun command string from the remote server, it will call CreateProcessA with FullPathOfProgramToRun.
This brings us to the end of this function and DLL. We now know that this DLL implements backdoor functionality that allows the attacker to launch an executable on the system by sending a response to a packet on port 80.
![1______](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/e0f28f17-2923-4fb9-92f0-80bb241fe240)

2- kerne132.dll on disk, and the presence of Mutex ‘SADFHUHF’ in DLL.

3- The program is a file infector that infects executables on the system to load a malicious remote access trojan that connects back to the IP 127.26.152[.]13. By examining Lab07-03.dll, we can conclude that this trojan takes either the command sleep, or exec, which is used to start a process of interest.

4- Due to the malware infecting every executable on disk it is very difficult to remove. Because it will be used by every process. Further if it is removed during deadbox analysis, it is likely the system will crash when booting due to no variant of kernel32.dll being present.
So u have to modify kerne132.dll to be the legitimate kernel32.dll, or even change the malware actions and recompile to instead modify all executables to point to the legitimate kernel32.dll instead of kerne132.dll, it may be easier to rebuild the system or restore from backup.

--------------------------------**This concludes CHAPTER 7**--------------------------------
## CHAPTER 9
### Lab 9-1
#### Questions
1. How can you get this malware to install itself?
2. What are the command-line options for this program? What is the password
requirement?
3. How can you use OllyDbg to permanently patch this malware, so that it
doesn’t require the special command-line password?
4. What are the host-based indicators of this malware?
5. What are the different actions this malware can be instructed to take via
the network?
6. Are there any useful network-based signatures for this malware?

#### Solution
1. At first, this malware uninstalls itself if you don’t provide the expected argument and password.
So, to be able to answer this question we need to figure out the argument and the password.
As mentioned in the challenge description we will analyze this malware using IDA pro and OllyDBG but instead of Olly, I’ll use x64DBG.
When we load the malware into IDA it will go directly to main, we will see a comparison between argc and 1.
![1-argc](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/9bb03308-1573-4fd9-9d55-d11724b98e6f)

---
In this case i haven't enter any args so it will jump to perform sub_401000.
Taking a look at this funciton we can see that the malware will try to open REG(SOFTWARE/MICROSOFT/XPS), but it falis because RegOpenEax returns a nonzero error code"2" into EAX.
![1-OpenRegKey](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/9ca42c92-60d9-4a01-b010-18c1c32d954d)

---
Now the malware will take a jump to perfrom sub_402410.
By debugging this function it will take the malware path and its name using (GetModuleFileNameA) and (GetShortPathNameA) and delete it using del command combined with cmd.exe using (ShellExecuteA).
![1-del](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/1b0309e2-d1a5-4d4a-b3c0-34ee9d9b42f6)
![1-ShellExe](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/34c3791f-95c0-47c0-beab-b2d325c03f4f)

---
Now lets debug the main to figure out the argument and password.
After re-debugging the malware with x64dbg and passing any password(in this case qwer), Now malware will take the password and check if it is the right one, but we know it's just a test password and won't be the correct password, now we need to know the right password.
![1-sub_402510](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/220aa4a9-314b-44fd-80d6-17af84a45480)

---
Inside the funciton(sub_402510), it will make some checks and compare the size of password with 4 so we need a password like "qwer".
![1-cmpECX](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/0718b48c-8839-4715-8b9d-c1213d8dcb09)

---
After passing this condition, malware will check the password char by char.
![1-CheckPass](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/bd9d03be-10a1-4746-8458-cc03ef5152f3)

After debugging this function and converting the code into python to understand it simply we can figure out that the right password is "abcd"
![1-abcd](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/28d31350-954e-4a64-8d27-6de5f60298a2)

---
- After this, we can use IDA to explore the rest of the code to see the right arg.
After password verification, it will check for the arg and after debugging in IDA, malware will perform some strings comparisons using __mbscmp.
After argument and password checking, the malware will compare argc again with 3 to make sure that there are 3 args.
Now we can see a calling to sub_4035B0 which taking the path of malware and split its file name.
![1-sub_4025B0](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/b1ec800d-19b6-426b-830e-a44cd734ecdc)

---
And now EAX contain the file name.
![1-EAX](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/f0b1d2a2-065a-40cf-8acd-3fe5dd8cabe2)

---
Then, back to main and continue execution we will see that ServiceName now is the malware name Lab09-01
(ServiceName)
Then, calling sub_402600 and inside it will see %SYSTEMROOT%\system32\ & .exe offsets and OpenSCManagerA calling, and we can see that a connection to the service control manager
![1-(sysroot)](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/cbb47092-042f-4d34-8359-b5ea217fc636)

---
![1-OpenServMan](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/24a45f86-3378-4078-9098-680c3b85fbef)

After that, it will check if the service with the same name is already exists or not by using OpenServiceA
![1-OpenServA](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/6ff2a9cc-1705-471f-9877-857e74785aed)

---
If the service already exists, malware will change its configurations to these configurations:
![1-change_malware_config](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/c8dccd0f-b78f-4dd5-88d3-d4231aed1cdd)

As we see in parameter dwStartType, it will make malware run automatically (persistence)
But in our case service doesn’t exists, so malware will create it with these configurations:
![1-create_new_service](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/9d8a1a8c-0797-4f37-902e-b65e95c0b489)

---
As we see it will also created as a startup service, and if we view services we will find service created succesfully and copy the orginal file to this service
![1-service_created](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/013a26ae-cfb9-4f45-b4b8-0db8bd26f8a0)

After malware copy itself, there are calling to function sub_4015B0 inside this function we will see some staff of creating file and get file time
![1-inside_sub_4015B0_1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/f96c8e95-a906-4efe-a274-489d2631ef5e)
![1-inside_sub_4015B0_2](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/ddba9b73-e622-40fe-8da2-3ad4dc5ab489)

---
IDK what is actually happened, but after returning from this function we will see ECX will be wow64cpu.dll
![1-wow64cpu dll](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/fd5b86bc-ec21-44bb-b876-d70c408bf2ef)

---
But, after this we will see URL http://www.practicalmalwareanalysis.com and two numbers (60, 80) and ups as arguments to sub_401070
![1-URL](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/f8150abc-41e8-43a5-9883-4c1dc5b0ad18)

---
Inside this function, there are many rep movsd and rep movsb instructions, and after all of these instrunctions, the malware will Create Registry key using RegCreateKeyExA in SOFTWARE\Microsoft \XPS
And then sets the data and type of a specified value under a registry key using RegSetValueExA
![1-Registry_key_set](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/6edb2d9b-b8d9-4dda-b4ce-831deb76cd67)

---
So, now malware installs itself and create a registy and sets its configration.
Q1- How can you get this malware to install itself?

- The malware will install itself as a service in the SYSTEMROOT directory.

---

2. In addition to the mentioned ‘-in’ argument check, we can see 3 other command-line options in this malware. “-re” “-c” and “-cc”
-in: Install the malware
-re: remove the malware (this option will delete malware service and its file in SYSTEMROOT directory)
-c: this option will also remove malware if argc != 7 and if it was = 7 it will create a registry key and set its values so I think this option to modify C2 url and the other two parameters (in our original case 60 & 80)
![2-c](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/a388e128-bf47-4093-85e4-e9b52b48ae93)
![2-cc](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/2c97c679-7527-419c-b042-f18b57f70c8a)

---

3. We can modify every je to be jmp or we can convert xor eax, eax to mov eax, 1, so we can enter any password and it will be accepted.

---

4. SOFTWARE\Microsoft \XPS Registry
   %SYSTEMROOT%\system32\ Directory

---

5. By opening this using IDA we can find sub_402020 which contains a number of instructions that help determine what different actions this malware can be instructed to take.
![5](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/89778c88-7ec1-478c-9a91-53e07236be34)

---

6. URL: http://www.practicalmalwareanalysis.com.

---

### Lab 9-2
#### Questions
1. What strings do you see statically in the binary?
2. What happens when you run this binary?
3. How can you get this sample to run its malicious payload?
4. What is happening at 0x00401133?
5. What arguments are being passed to subroutine 0x00401089?
6. What domain name does this malware use?
7. What encoding routine is being used to obfuscate the domain name?
8. What is the significance of the CreateProcessA call at 0x0040106E?

#### Solution
1. Some APIs, URLs, exe files and cmd.
![1-strings](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/dc0fac97-ff2b-4ad0-a1b9-66a4984838b2)

2. It is terminated almost instantly without showing any other visible actions.

3. At first, we can let IDA Pro use its FLIRT signature detection to correctly identify APIs.
IDA Pro identifies sub_0x401550 as _strrchr and sub_0x4014C0 as _strcmp.
![3-(_strrchar)](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/4191be51-f118-4d5a-ab78-1f11cb343cc0)
![3-(_strmp)](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/c65de3fb-912a-4c10-8dbb-3e5270467498)

By setting a breakpoint on the call at 0x401217. We can see two arguments being pushed on the stack. The first is a forward slash(0x5C), and the second is the value being returned from the GetModuleFileNameA call, which would be the current name of the executable.
![3-Bpstrrchar](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/efdc7247-b241-4571-b429-7384592a05b1)

The malware is searching backward for a forward slash (0x5C character) in an attempt to get the name (rather than the full path)
If we step-over the call to _strrchr, we can see that EAX is pointing to the string \Lab09-02.exe.
![3-lab9-2exe](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/ec4c2cbe-48ca-4c61-82a5-3515739bbc82)

The next function call that IDA identified it as _strcmp, We’ll determine which strings are being compared by setting a breakpoint on the call to _strcmp at 0x401236.
Once our breakpoint is hit, The first is the pointer to the GetModuleFileNameA call (incremented by 1 to account for the forward slash), and the other is ocl.exe
![3-Bp_strcmp](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/8c2d2a20-779d-4e67-a23e-67f4e1a438f0)

If the strings match, EAX will be ZERO, and test eax,eax will set ZeroFlag to 1 and execution will then go to 0x40124C, otherwise the program will exit, which explains why the malware terminated when we tried to execute it earlier.
![3-test exa,exa](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/b2072ee7-93de-4895-befc-794895527507)

From this we can figure out that the malware must be named to ocl.exe in order to execute.

4. Diving into 0x00401133, we can see that a number of hex values are being moved onto relevant area of the stack segment.
This is a common string obfuscation technique.
If we take the hex values accounting for the null values present and convert this to ascii we get the following:
31 71 61 7a 32 77 73 78 33 65 64 63 = 1qaz2wsx3edc
6F 63 6C 2E 65 78 65 = ocl.exe
![4-0x00401133](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/d4853350-b4d0-4513-8d7d-de47426aa3c0)

5. By setting a breakpoint at 0x00401089 and running, we can see that 1qaz2wsx3edc and a pointer to 0x12FD58(IncI ESi) are being passed.
![5-0x00401089](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/b3ee9cca-1e2f-4ee1-9e41-c1e660d60daf)

6. If we start to debugging sub_0x00401089, we will see some kind of decoding routine to decode Str using XOR operation, After this function has finished its work if we look at memory dump we will see the result is www.practicalmalwareanalysis.com
![6-PMA com](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/6a4d009d-7d65-4b10-ac22-6364345464bb)

7. XOR encoding.
![7-xor](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/482ead9a-ca4f-4827-b295-9033895e66ed)

8. By examining this in IDA, we can see that it is making cmd.exe window hidden, in addition to specifying the standard input, output, and error streams be sent to an argument that’s passed into this function.
![8-CreateProcessA](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/321ee4fe-c9bd-4a89-a2ad-d49109e5baff)

Looking at the only calling function to this, we can see that the argument passed to this is the established socket to the C2. We now know that this process acts as the reverse shell allowing access to this host.
![8-(C2)](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/13a0789c-4481-4990-a07c-8c9f383aad72)
![8-(C2_)](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/fc6903ea-d996-461d-8b6e-c6f29b931c35)

---

### Lab 9-2
#### Questions
1. What DLLs are imported by Lab09-03.exe?
2. What is the base address requested by DLL1.dll, DLL2.dll, and DLL3.dll?
3. When you use OllyDbg to debug Lab09-03.exe, what is the assigned based
address for: DLL1.dll, DLL2.dll, and DLL3.dll?
4. When Lab09-03.exe calls an import function from DLL1.dll, what does
this import function do?
5. When Lab09-03.exe calls WriteFile, what is the filename it writes to?
6. When Lab09-03.exe creates a job using NetScheduleJobAdd, where does it get
the data for the second parameter?
7. While running or debugging the program, you will see that it prints out
three pieces of mystery data. What are the following: DLL 1 mystery
data 1, DLL 2 mystery data 2, and DLL 3 mystery data 3?
8. How can you load DLL2.dll into IDA Pro so that it matches the load
address used by OllyDbg?

#### Solution
1. By openint exe in IDA we can see that the imported DLLs are:
DLL1.DLL
DLL2.dll
KERNEL32.dll
NETAPI32.dll
![dll](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/46907283-8016-4ef7-8b30-32bc508bf8f3)

In addition to these, if we examine calls to the WinAPI ‘LoadLibraryA’, we can find another 2 DLLs that are dynamically loaded into memory.
DLL3.dll
user32.dll
![1-dll2](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/e5989485-038f-4774-9e92-c9d1ca378d84)
![1-dll3](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/55d96df3-1b4a-4aff-9dca-5cc60c0d375d)

2. Using PE-bear, we can see that they all have an image base address set to 0x10000000.
![2-BA1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/df75fd2b-19ce-495c-8e8c-b1c07b97052d)
![2-BA2](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/04ca8874-0451-424f-ba59-64e098174708)
![2-BA3](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/604d0abe-c412-42dd-9a42-f60d61d278a9)

3. At first, we have to run mthe malware until all DLLs are loaded into memory, we can use ALT+M to view the programs memory(MemoryMap).
Note: These values will likely differ per run through or system.
Because we know that DLL3.dll is dynamically loaded, we'll need to add breakpoint after this loadlibrary call to check when all 3 are loaded into memory.
![3-loadlibrary](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/631f9c6b-6377-4ab7-a91a-1ec509f87b2d)

Now lets take a look at memory map.
![3-BA](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/cfe1a012-4739-4790-a7bd-d85a44c74013)

DLL1 -> 0x00250000
DLL2 -> 0x00260000
DLL3 -> 0x00270000

4. Because this occurs prior to the breakpoint we previously set, we can get our first glimpse on what has happened by viewing the program output while it is at our breakpoint.
![4-output](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/d356c7cd-cd63-4ca4-b6c8-fc403f9adfae)

This appears to display an output of “DLL 1 mystery data”, and then a number. We can gather more information by disassembling this in IDA.
![4-dll1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/147afbd5-c16e-4508-9112-35fb39e2b846)
![4-DLL_1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/9ea5e96f-3a96-40fd-822a-360c89d4e8a6)

Based on this we conclude that this is printing out the current processID of the process in which the DLL has been loaded into.

5. We need to look at both DLL2.dll, and Lab09-03.exe.
In Lab09-03.exe the malware calls and moves the output into [ebp+hfile] before passing it a buffer of the characters “malwareanalysisbook.com” to write.
![5-ebp+hfile](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/2cf6d364-a44e-4b4c-a8cd-72b565f75f84)

By examining DLL2.dll, and looking at the exported DLL2ReturnJ function.
![5-DLL2exp](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/505eeb25-8eb4-4f18-9931-5c11e58cf305)

We can see that this exported function returns a value stored under dword_1000B078.
![5-expretval](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/5c1a24c5-ab57-423d-b0d0-0a11860ea63d)

This value assigned based on the DLLs Main method as a handle to a file named “temp.txt”.
![5-temp](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/1e3abe8b-6c77-4cd4-9ef9-cea2da28565c)

Based on this we can say that this writes “malwareanalysisbook.com” into a file named “temp.txt”.

6. Taking a look at this execution we can see that it passes 3 parameter items: JobID, Buffer, and Servername.
![6-params](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/8aba7579-5642-410f-acf8-dccfc67fad3e)
![6-paramss](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/346176a4-19f8-4f2d-9375-83b5f83d78b2)

The second parameter is buffer(in this case it is a pointer to an AT_INFO structure describing the job to submit) which is called from the output of Dll3GetStructure.
![6-Buffer](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/6d613512-a3b1-4158-ab29-aa11097d2368)

And if we look a bit above we will see dynamic calling to DLL3GetStructure from DLL3 and the buffer is the input of this function.
![6-BufferDLL3GetStructure](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/c64610e4-5c9b-4a1b-bc29-392fcfc51d8b)

By examining this duction we can figure out that it only moves dword_1000B0A0 and return.
![6-DLL3GetStructure](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/88d7b971-086f-4404-9c7c-7fad12a69baa)

And if we look at the XREF of this variable, we will see that it initialized in the main of DLL3, and a call to MultiByteToWideChar which maps a character string to a UTF-16 (wide character) string, and it takes “ping www.malwareanalysisbook.com” as a string to convert.
![6-MultiByteToWideChar](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/23f44170-75f7-410e-a12c-3754d641505c)

Now we can say that it is a pointer to the structure which contains information about the scheduled task which is “ping www.malwareanalysisbook.com”
Based on this we can see that it will ping www.malwareanalysis every day at 3600000 milliseconds (60mins) past midnight (1am).
![6-60mins](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/efcbcad8-63ff-4879-9ddf-00c797166b5c)
![6-AT-INFO](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/52448307-568b-4042-8c44-526a5880e070)

> [!NOTE]
> When I was lokking for NetScheduleJobAdd in MSDN I found that this function was not longer used since windows 8.

7. We already know what these are by the analysis conducted in previous questions. These are outputted from the values found in our relevant DLL files.
- DLL 1 mystery data 1: Process ID DLL is running under. (This was found in Question 4).
- DLL 2 mystery data 2: Handle ID for the Handle on file temp.txt. (This was found in Question 5).
- DLL 3 mystery data 3: Memory location of the converted string “ping www.malwareanalysisbook.com”. (This was found in Question 6).

8. Taking the address where DLL is loaded and starting IDA to load DLL then selecting manual load and specify the new image base.
![8-manualload](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/88de9c8e-66e1-49ad-8d62-e559ff132856)
![8-add](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/126dcebb-69ff-48b0-bcd6-49b38e32be1c)
![8-dllfile](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/526b8a28-cf26-45cd-8b91-d01aadaa65b0)

--------------------------------**This concludes CHAPTER 9**--------------------------------
