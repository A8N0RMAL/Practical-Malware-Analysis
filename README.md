# Practical-Malware-Analysis
Write up for PMA labs solution

---

## CHAPTER 1
### Lab 1-1
#### Questions
1. Upload the files to http://www.VirusTotal.com/ and view the reports. Does
either file match any existing antivirus signatures?
2. When were these files compiled?
3. Are there any indications that either of these files is packed or obfuscated?
If so, what are these indicators?
4. Do any imports hint at what this malware does? If so, which imports
are they?
5. Are there any other files or host-based indicators that you could look for
on infected systems?
6. What network-based indicators could be used to find this malware on
infected machines?
7. What would you guess is the purpose of these files?
#### Solution
1- These files were written specifically for this book, so as of this writing,
you should not find a signature for them on VirusTotal.com. Of course, if
these files become part of the antivirus signatures as a result of the publi-
cation of this book, the results will be different.

2-Both files were compiled on December 19, 2010, within 1 minute of each other.
![dll](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/0640abd7-1014-4143-bcbd-8c1807e03a88)
![exe01](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/e83893ce-ef66-41fc-bc9f-3f7e8afb34e1)

3- There are no indications that either file is packed or obfuscated, PEiD labels this as unpacked code compiled with Microsoft Visual C++,
which tells us that these files are not packed.
![Unpackeddll](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/c30663f6-43f0-4fb2-96bc-696456578b0d)
![Unpackedexe01](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/2362d06b-7645-4fe6-8f77-d2f9001cfebe)

4- The interesting imports from Lab01-01.exe are FindFirstFile, FindNextFile,
and CopyFile. These imports tell us that the program searches the file-
system and copies files. The most interesting imports from Lab01-01.dll
are CreateProcess and Sleep. We also see that this file imports functions
from WS2_32.dll, which provides network functionality.
![exe01](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/ed8bfaac-8c8c-458c-a3c0-bcdc30a1ed7a)

5- Examine C:\Windows\System32\kerne132.dll for additional malicious activ-
ity. Note that the file kerne132.dll, with the number 1 instead of the letter
l, is meant to look like the system file kernel32.dll. This file can be used as
a host indicator to search for the malware.

6- The .dll file contains a reference to local IP address 127.26.152.13. This
address is an artifact of this program having been created for educational
and not malicious purposes. If this was real malware(and that is :') ), the IP address should
be routable, and it would be a good network-based indicator for use in
identifying this malware.

7- The .dll file is probably a backdoor because it imports functions
from WS2_32.dll, which provides network functionality and we also see two interest-
ing functions imported from kernel32.dll: CreateProcess and Sleep, which are
commonly used as backdoors. These functions are particularly interesting to
us in combination with the strings exec and sleep. The exec string is probably
sent over the network to command the backdoor to run a program with
CreateProcess. The sleep string is probably used to command the backdoor
program to sleep. The .exe file is used to install or run the DLL.
> [!NOTE]
> Hackers use backdoors to communicate with a command-and-control server and bypass security

> [!IMPORTANT]
> Backdoor -> Malicious code that installs itself onto a computer to allow the attacker access. Backdoors usually let the attacker connect to the computer with little or no authentication and execute commands on the local system.

![how_a_backdoor_attack_works-f](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/8ece181f-8d26-452b-bb76-99be989936c0)

---
### Lab 1-2
#### Questions
1. Upload the Lab01-02.exe file to http://www.VirusTotal.com/. Does it match
any existing antivirus definitions?
2. Are there any indications that this file is packed or obfuscated? If so,
what are these indicators? If the file is packed, unpack it if possible.
3. Do any imports hint at this program’s functionality? If so, which imports
are they and what do they tell you?
4. What host- or network-based indicators could be used to identify this
malware on infected machines?
#### Solution
1- The file matches 55 of 70 antivirus signatures.
![Virustotal](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/47419c31-aac3-4979-b189-38096aec5618)

2- Using Exeninfo, Detect it easy and PEiD, we should see that the file is packed with UPX if u have to unpack it download upx and run this command -> upx.exe -d filename.exe
Note : In Normal mode in PEid u see nothing but when u try Deep-Mode u will see that file is packed (:'
![Packed](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/d4fdfb1d-5dc0-4b0a-9266-2d2cf2a6c4bf)
![Deep-ModePEiD](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/9a1b2e1d-d2a4-44ca-b251-8a7d5eeda556)

3- After unpacking, we look at the imports sections and the strings. The
imports from kernel32.dll and msvcrt.dll are imported by nearly every program,
so they tell us little about this specific program. The imports from wininet.dll
tell us that this code connects to the Internet (InternetOpen and InternetOpenURL),
and the import from advapi32.dll (CreateService) tell us that the code creates a
service. When we look at the strings, we see www.malwareanalysisbook.com, which
is probably the URL opened by InternetOpenURL as well as by Malservice, which
could be the name of the service that is created.
![UnpackingFile](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/2128ac78-b00a-41d6-a0f8-e1f969c32a66)
![Strings](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/f8a4bbf9-7ef8-4018-af27-fab8312e06d2)

4- We can’t be sure what this program is doing, but we’ve found some indicators to help search for this malware across a network.

---
### Lab 1-3
#### Questions
1. Upload the Lab01-03.exe file to http://www.VirusTotal.com/. Does it match
any existing antivirus definitions?
2. Are there any indications that this file is packed or obfuscated? If so,
what are these indicators? If the file is packed, unpack it if possible.
3. Do any imports hint at this program’s functionality? If so, which imports
are they and what do they tell you?
4. What host- or network-based indicators could be used to identify this
malware on infected machines?
#### Solution
1- 61 of 71 virus engines identify this sample as malware.
![VirusTotal](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/37599913-63f3-4933-978b-cede707d9120)

2- The file is packed with (FSG 1.0), but we can’t unpack it at this time.
>[!NOTE]
>Not always ur tool will give u the exactly result ,so try using several tools as showen here Exeninfo couldn't recognize that the file is packed but other tools can recognize that.

![PackedFile](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/0a5fea37-a1de-46c5-927b-a3d01eef75c6)

3- This question can’t be answered without unpacking the file.

4- This question can’t be answered without unpacking the file.

---
### Lab 1-4
#### Questions
1. Upload the Lab01-04.exe file to http://www.VirusTotal.com/. Does it match
any existing antivirus definitions?
2. Are there any indications that this file is packed or obfuscated? If so,
what are these indicators? If the file is packed, unpack it if possible.
3. When was this program compiled?
4. Do any imports hint at this program’s functionality? If so, which imports
are they and what do they tell you?
5. What host- or network-based indicators could be used to identify this
malware on infected machines?
6. This file has one resource in the resource section. Use Resource Hacker
to examine that resource, and then use it to extract the resource. What
can you learn from the resource?
#### Solution
1-  59 of 71 antivirus engines identify this as malicious code that downloads and/or drops additional malware onto a system.
![VirusTotal,PNG](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/783b8e9e-21cc-47b2-94f6-bd9b41960466)

2- There are no indications that the file is packed or obfuscated.
![UnpackedFile](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/cb6fd92b-7330-4b08-b60d-4a99d6d4e200)

3- This program was compiled at Fri Aug 30 22:26:59 2019 | UTC, and this compile time is faked.
![CompilingTime](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/6979c6e2-d458-411b-a8ad-536d77feff87)

4- The imports from advapi32.dll indicate that the program is doing something with permissions. The imports from WinExec and WriteFile, along with the results from VirusTotal.com, tell us that the program writes a file to disk and then executes it. There are also imports for reading information from the resource section of the file.
![Imports](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/05901bd5-de42-476a-b87c-88144300b128)

5- The string \system32\wupdmgr.exe indicates that this program could create or modify a file at that location. The string www.malwareanalysisbook.com/updater.exe probably indicates where additional malware is stored, ready for download.
![Strings](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/a9bfa6d1-0671-4824-beda-0bad70d04d27)
![Strings1](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/7d4829ce-ae79-4d45-82f3-61ccfae83ab5)
![Strings2](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/dab6fc9a-f42f-4373-ad93-05736d0b4d43)

6- The resource section contains another PE executable. Use Resource
Hacker to save the resource as binary data, and then analyze the binary
file as you would analyze any executable. The executable in the resource
section is a downloader program that downloads additional malware, because it accesses the network functions. It calls
URLDownloadToFile, a function commonly used by malicious downloaders. It
also calls WinExec, which probably executes the downloaded file.
![BinFile](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/9dbe5bbc-40eb-4f50-8209-652fbdce63e9)

--------------------------------**This concludes CHAPTER 1**--------------------------------

---

## CHAPTER 5
### Lab 5-1
#### Questions
1. What is the address of DllMain?
2. Use the Imports window to browse to gethostbyname. Where is the import
located?
3. How many functions call gethostbyname?
4. Focusing on the call to gethostbyname located at 0x10001757, can you figure
out which DNS request will be made?
5. How many local variables has IDA Pro recognized for the subroutine at
0x10001656?
6. How many parameters has IDA Pro recognized for the subroutine at
0x10001656?
7. Use the Strings window to locate the string \cmd.exe /c in the disassembly.
Where is it located?
8. What is happening in the area of code that references \cmd.exe /c?
9. In the same area, at 0x100101C8, it looks like dword_1008E5C4 is a global
variable that helps decide which path to take. How does the malware set
dword_1008E5C4? (Hint: Use dword_1008E5C4’s cross-references.)
10. A few hundred lines into the subroutine at 0x1000FF58, a series of comparisons
use memcmp to compare strings. What happens if the string comparison
to robotwork is successful (when memcmp returns 0)?
11. What does the export PSLIST do?
12. Use the graph mode to graph the cross-references from sub_10004E79.
Which API functions could be called by entering this function? Based on
the API functions alone, what could you rename this function?
13. How many Windows API functions does DllMain call directly? How many
at a depth of 2?
14. At 0x10001358, there is a call to Sleep (an API function that takes one
parameter containing the number of milliseconds to sleep). Looking
backward through the code, how long will the program sleep if this code
executes?
15. At 0x10001701 is a call to socket. What are the three parameters?
16. Using the MSDN page for socket and the named symbolic constants functionality
in IDA Pro, can you make the parameters more meaningful?
What are the parameters after you apply changes?
17. Search for usage of the in instruction (opcode 0xED). This instruction is
used with a magic string VMXh to perform VMware detection. Is that in use
in this malware? Using the cross-references to the function that executes
the in instruction, is there further evidence of VMware detection?
18. Jump your cursor to 0x1001D988. What do you find?
19. If you have the IDA Python plug-in installed (included with the commercial
version of IDA Pro), run Lab05-01.py, an IDA Pro Python script
provided with the malware for this book. (Make sure the cursor is at
0x1001D988.) What happens after you run the script?
20. With the cursor in the same location, how do you turn this data into a
single ASCII string?
21. Open the script with a text editor. How does it work?
#### Solution
1- DLLMain is found at 0x1000D02E in .text section.
![13](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/350f10c8-9091-4439-87be-1a5cc0182585)

2- gethostbyname is found at 0x100163CC in .idata section.
![gethostbyname_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/077e06d7-dfd6-4ed9-869c-70febc0abfde)

3- gethostbyname is called 9 times by 5 different functions
throughout the malware.(go to gethostbyname function and press x to get xRefs to this func.)(The text “Line 1 of 18” at the bottom
of the window tells us that there are nine cross-references for gethostbyname.
Some versions of IDA Pro double-count cross-references: p is a reference
because it is being called, and r is a reference because it is a “read” reference
(since it is call dword ptr [...] for an import, the CPU must read the import
and then call into it))
![gethostbyname](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/9ed6d696-3c7d-4719-a1ce-e1a246b2c8cd)

4- A DNS request for pics.practicalmalwareanalysis.com will be made by the
malware if the call to gethostbyname at 0x10001757 succeeds.
(press G to quickly navigate to 0x10001757, start following z code, it seems like gethostbyname function takes a single parameter so u have to figure out what is in EAX,  It appears that off_10019040
is moved into EAX. If we double-click that offset, we see the string [This is
RDO]pics.practicalmalwareanalysis.com), and if we adding 0xD to EAX the pointer to location of URL will be like this in figure gethostbynameDNS.PNG)
![Screenshot06](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/fc66db85-75a4-4b49-816a-8555e6dbc987)
![gethostbynameDNS](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/c1138548-cc1a-44b4-a1e1-43e811271ffc)
![Screenshot07](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/042b97ab-4c73-40fa-831e-08791be48acb)

5- 23 local variables (local variables correspond to negative offsets)
just press G to navigate to 0x10001656, Simple friend :"
![Screenshot08](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/21610934-fa65-49a7-ab3f-bf4b0c1d6067)

6- There is onle one parameter labeled -> lpThreadParameter(The parameters correspond to positive offsets)

7- The string resides in xdoors_d section at 0x10095B34

8- That area of code appears to be creating a remote shell session for the attacker. 
By following the xref to the subroutine which references \cmd.exe /c
This function shows a series of memcmp functions that are comparing strings such as cd, exit, install, inject, and uptime.
We’re able scroll through the function to see a number of interesting values being pushed to the stack, in this case the values: quit, exit, and cd catch our eyes.
Continuing on we can see entries such as: idle, uptime, mmodule, minstall, and inject all catch out eyes.
Finally if we look around this function we can find that the char array aHiMasterDDDDDD mentioning a ‘Remote Shell Session’, and ass such we can infer we’re looking at a remote shell session function.
![8](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/5d858127-2e93-494e-9f06-8939430d2377)
![8_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/474205ae-504d-47a7-a752-07f2b3ba35de)
![8__](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/f21474de-b2e9-4d76-987f-6d5cbe18dddc)
![8___](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/1ff1b9ff-5c24-401d-a5ab-b153b127878e)
![8____](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/8a5f45b6-5131-4cab-9cb7-8428306cbe0a)


9- The OS version is stored in the global variable dword_1008E5C4.
Starting at address 0x100101C8 we can see a comparison statement comparing ebx to dword_1008E5C4, and viewing the cross-references to this we can find one of them which actually contain the mov statement to set the value.
Following this we can see that the output of sub_10003695 will be moved directly into dword_1008E5C4.
So by looking into this routine we can find that it is comparing the dw platform ID to the value ‘2’:
By running some searches based on this we find the following documentation on PlatformID
This tells us that the field 2 indicates the operating system is Windows NT or later.
![9](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/36d2b4c1-97d0-418b-b718-92b2d2b92bcf)
![9_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/df16ff45-f4af-4448-90fc-0020b809b5a1)
![9__](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/142aac72-a039-45c4-acae-ccb6e96e38c2)
![9___](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/62371c6a-8f5a-4e16-b8e3-189444622f5f)


10- The registry values located at HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WorkTime and WorkTimes are queried and sent over a network socket.
Looking into this routine we can find the entry comparing “robotwork” which uses a JNZ branch.
Because of this the jnz is NOT taken, and we end up running a call to the subroutine sub_100052A2, so let’s take a look into it.
From this we can see that it is opening a registry key at: HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion, in this case jz statement checks if the registry was successfully opened or not.
Zero flag IS set, so let’s follow loc_10005309.
Here we can see it is querying WorkTime, and WorkTime registry keys. If we look back at where this opened the registry key we can see that it is passing an argument type of “Socket” with the value ‘s’. Looking back at the start of this question we can see that this pushes ebp+s which indicates this information is sent back over the passed network socket.
![10](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/acd9222b-36fe-44e6-b372-56fc25790ee5)
![10_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/7c1e5060-6e4d-438d-b1e2-04c26dc6d565)
![10__](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/aff9dc2a-2cba-456a-886c-f7023f9096d4)
![10___](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/baa26bb8-c0da-45db-829d-8c74cd463dd2)

11- By looking into the exports within this DLL we can find PSLIST. Following this and pressing SPACE leads us to the IDA Graph view.
From here we can see that one of 2 paths will be taken depending on the result of sub_100036C3, so let’s dive a bit deeper there.
we can see this is checking whether the operating system is Windows NT or later;
then checking if it’s major version is 5. So let’s look at what this represents by looking at the documentation on OSVERSIONINFOEXW structure.
So we now know it is checking whether the OS is any of these versions. Depending on the output it will either run sub_10006518 or sub_1000664C.
Taking a closer look at sub_10006518 we can see based on the API call to CreateToolhelp32Snapshot, strings, and the function name that this will allow them to grab a process listing.
Looking further at sub_1000664C, we can see that this performs the same type of calls as sub_10006518; however, this also sends through reference to the socket to send the output back to.
Both code paths return the process listing over the socket using send.
![11](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/0c0e5ba9-7eb4-49f8-8df2-d1dc77a182ea)
![11_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/d282cdb6-af93-40e2-8823-391785d3cf87)
![11_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/2fde1d19-bef9-4e0c-b06c-05606ebe9ae4)
![11__](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/863758ec-bf74-4c2b-8aea-7927839fc6f4)
![11___](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/fb8d0d15-5783-46aa-8afd-8ba6cfe0f351)
![11____](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/afcb3b2b-bf89-43e6-be80-8bbf10864c3c)
![11_____](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/f18cf8d7-5b7f-4665-bc9e-f8056b0c9a09)

12- GetSystemDefaultLangID, send, and sprintf are API calls made from sub_10004E79. This function could be renamed to something useful like GetSystemLanguage.
press G to go to address 0x10004E79 and then view xRefs from this function.
![12](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/40ed5171-ef93-48fc-b651-5cc814442136)

13- By clicking View > Graphs > User xrefs chart, and then adjusting the settings to start and end at the function DLLMain with a depth of 1, we’re able to see 4 Windows API Functions.
If we expand this to a depth of 2, the chart blows out in size and we’re looking at 33 including duplicates.
![13](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/b41b90a4-db9c-404d-9b32-42e6b171a426)
![13_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/5a5a161f-7840-4020-b95e-f5a6977e91a4)
![13__](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/e80a1cb9-7c67-4188-be98-5c727ad07cd8)
![13___](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/07230168-b2c2-426a-83ce-14427454f171)

14- Moving back from the call to sleep, we can see that EAX is multiplied by 1000 before being pushed to the stack and called. This matches the reference to milliseconds, in that there are 1000 milliseconds in a second.
If we follow the previous routine at offset 10019020 (off_10019020), we see it points to the data [This is CTI]30 .
Looking back at the commands  it is then adding 0Dh (13) to EAX which moves the pointer past the text ‘[This is CTI]’ leaving only ‘30’.
Based on the call to atoi this is then converted to a number before being multiplied by 1000 and as such the program will sleep for 30 seconds if this executes.
![14](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/fd0bbffa-6d82-482b-8174-53a3f9b0c397)
![14_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/508d13ec-ed24-4de6-a302-9f78818fcabd)
![14__](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/1b41a105-9b1f-45d8-a4c6-33d3d48b1279)

15- Looking at this address we can see a call to socket which takes 3 parameters (protocol, type, and af) all of which are pushed to the stack prior to the call.
![15](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/df693ea3-0769-4d02-98f7-9203d3e92c82)

16- By looking into the MSDN Socket Function we can find what these numbers correlate to.
y right clicking and selecting Use Standard Symbolic Constant, we’re able to quickly change these to accurately reflect their assigned values.
![16](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/4dcfee31-a970-49ff-a7ad-85183e78a769)
![16_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/4ecba8a1-fad6-4f39-b762-e0c69b21bd8f)
![16___](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/34a048bd-3751-4235-8be0-eaf6ed045832)
![16____](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/4ca19119-6756-4334-bebb-20a4a9605a15)

17- By searching for ‘ED’ as a sequence of bytes (ALT+B) we can find only one occurrence of the instruction ‘in’
Diving into this function we can see it is checking for the value VMXh which indicates this malware is implementing a known anti VM technique.
Looking at the Xrefs to this function we can see a reference to locating a VM in use and cancelling installation.
![17](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/88872aac-1752-44c0-a9e9-693c53314929)
![17_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/96d99c76-e93d-4ab9-8218-2b28bf0afb12)
![17__](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/c2b40cff-843d-4a73-895b-0f673e47c31f)

18- If we jump here using ‘G’ we find a bunch of seemingly random data.
![18](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/8270bf3d-0106-4b20-94ea-22c983bbfabf)

19- From this we can see it will loop through from our current position (0x1001D988) up to 50 bytes and run an XOR command over all of them by 0x55. From this we can infer that the script will de-obfuscate the seemingly random data.
![19](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/91300ee3-4346-40ed-88e5-2735096c9df1)

20- This can be done by pressing A on the string, we wind up with gibberish still because each element still requires the XOR function.
We can also see there’s been some overlap of hex indicated by the ,27h,’ elements. By removing these and running the XOR command over all of the strings concatenated using CyberChef(https://gchq.github.io/CyberChef/) we get a hidden message.
![20](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/9f21fab6-b4e0-4ea0-9c5c-7a40b291ae6a)
![20_](https://github.com/A8N0RMAL/Practical-Malware-Analysis/assets/119806250/182f2ec7-0339-4ba0-8a71-d4133a0ac8d4)

21- In this instance we can see that there’s been some issues bringing back any capitalisation somewhere along the line and this should read “xdoor is this backdoor, string decoded for Practical Malware Analysis Lab :)1234”. This is yet another benefit of us running this through the python script; however, the purpose still stands based on how the python script works. It will loop through from our position (0x1001D988) up to 50 bytes and run an XOR command over all of the values individually by 0x55

--------------------------------**This concludes CHAPTER 5**--------------------------------

---

## CHAPTER 6
### Lab 6-1
#### Questions
1. What is the major code construct found in the only subroutine called by main?
2. What is the subroutine located at 0x40105F?
3. What is the purpose of this program?

#### Solution
1- if statement located at 0x401000.
by starting at the main func. we see call    sub_401000, moving into it there is a compare statement before JZ jump, from this and graph view we can recognize that it's (if) code construct.
![Capture](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/5590a200-4d80-458e-90a0-3bcb86081f98)

2- By looking at the values that pushed into the stack, we can say that it's (printf) function.
![Capture0](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/c4d852bc-cf9c-454f-87b1-2750fd60d354)
![Capture1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/59115a17-70dc-49da-ab6b-3dbcc6872474)

3- This program checks internet connection and responds with 1 or 0 based on your cennection.

---

### Lab 6-2
#### Questions
1. What operation does the first subroutine called by main perform?
2. What is the subroutine located at 0x40117F?
3. What does the second subroutine called by main do?
4. What type of code construct is used in this subroutine?
5. Are there any network-based indicators for this program?
6. What is the purpose of this malware?

#### Solution
1- By looking at the main func. we can see that it calls sub_401000, diving into this function we can see that it gets internet connection state and responds with 1 if connects otherwise 0.
![Capture](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/5d288997-822d-4b51-bc13-93ee760961cf)
![Capture0](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/de4afa8c-41fd-4627-b500-5a51bc525fce)

2- Taking a look at Xrefs to this subroutine we can see that it' called by main func. and before calling this subroutine there are 2 parameters are pushed into the stack, first is string ("Success: Parsed command is %c\n") and the second is var_8 returned from the previous call at 0x401148. so we can deduce that printf is the subroutine located at 0x40117F.
![Capture1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/2ccf686f-ad78-4cbf-a5fe-39413eca51f0)

3- By looking at sub401040 we can see that this attempts to open the URL http://www.practicalmalwareanalysis.com/cc.htm and if it is successful, it will read in the first 0x200 (512) bytes into a buffer.
![Capture2](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/c7d17090-0c8e-4dbd-aea7-a72d39ec04d6)
![Capture3](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/8835a430-d6ef-478d-a067-3bac8ff303b2)

4- After looking at func. we can wee 2 different pathways, one where it is able to read HTML file and the other if it failed.
Diving into code where it successfully read the HTML file, we can see multiple compare statements based on 4 characters from the buffer "<!--" and we know that it's a start of a comment.
![Capture5](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/df8a2bdb-05cd-4697-a0e4-9e5fda079a0d)

5- There are two network-based indicators. The program uses the HTTP User-Agent Internet Explorer 7.5/pma and downloads the web page located at: http://www.practicalmalwareanalysis.com/cc.htm (URL to be opened).

6- The purpose of this malware is to check if there is an active internet connection, if there is it will proceed to try and open the URL http://www.practicalmalwareanalysis.com/cc.htm using the User-Agent ‘Internet Explorer 7.5/pma’ and if it is successful, it will read in the first 0x200 (512) bytes into a buffer, if not it will terminate. From this buffer the characters ‘<!–’ are read, and if they don’t exists the error message “Error 2.3: Fail to get command\n” is printed.
if these do exist, it will print the message “Success: Parsed command is %c\n”, where %c is the character read from the HTML comment buffer. We can also see this will wait 60000 milliseconds (1 minute) before terminating.
![Capture6](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/c97bcad2-7350-46ed-8871-a1dcfe7dafec)

---

### Lab 6-3
#### Questions
1. Compare the calls in main to Lab 6-2’s main method. What is the new
function called from main?
2. What parameters does this new function take?
3. What major code construct does this function contain?
4. What can this function do?
5. Are there any host-based indicators for this malware?
6. What is the purpose of this malware?

#### Solution
1- The new function called is sub_401130.
![Capture](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/f1c6cfdf-0f9c-44be-a2dd-f08fb6e0e5e3)

2- It takes 2 parameters char and LPCSTR(Long Pointer Constant String) lpExistingFileName.
There are 2 items are pushed (argv, var_8).
in this instance argv represents argv[0] which points to the name of the program, we can see that var_8 is set to AL at 0x401228. this means that the lower 8 bits(char in this case ) from sub_401040 becomes var_8, and we knew that sub_401040 allocates bytes to a buffer and then checks for "<!--", depending on what we knew we can say that the next byte (char) after "<!--" is that byte being passed to the function.
![Capture0](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/652c435f-b911-46d6-9a71-cc0286eb7643)
![Capture1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/2515517b-b0d7-4c8c-ae5b-f06ef0f9e61f)

3- Switch statement with a Jump Table.
![Capture2](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/8047c624-011a-4a9b-b46b-c841482f4782)

4- The function subtracts 'a' from whatever passed to it, if it's 'a' it will have value 0, b value 1, c value 2 and so forth...
In the case of this function, depending on the letter you send it (after ‘<!–-’ in the HTML), between ‘a’ and ‘e’, it will run a different set of commands.
If cmp instruction more than 4 it will jump to the default case
jmp multiplied by 4 as each adddress is 4 bytes long.
Taking a look at the cases :
- 'a' (97 ASCII)-> The program creates a directory at "C:\\Temp"
- 'b' (98 ASCII)-> The program copies lpExistingFileName(the program name) into "C:\\Temp\\cc.exe"
- 'c' (99 ASCII)-> The program deletes the file located in this path "C:\\Temp\\cc.exe"
- 'd' (100 ASCII) -> The program sets a value "Malware" in the windows registery for presistence, it sets Software\Microsoft\Windows\CurrentVersion\Run\Malware to C:\Temp\cc.exe, which makes the malware starts at the system boot.
- 'e' (101 ASCII) -> The program Sleeps for 100,000 milliseconds (100 seconds)
- Finally, the default case -> Display the error message “Error 3.2: Not a valid command provided”
![Capture3](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/5b35f8fd-f6a9-4f2f-a0bf-61a729955f72)
![Capture4](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/2dc90543-5fc1-42c4-a072-01a5e2c858db)
![Capture5](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/5dd1303c-fad8-45e0-bff6-dac33a0ba967)

5- The host based indicators from this are the file the malware will copy itself to, and the registry key used for persistence.
Note: A quick search reveals that 80000002h which is pushed to the stack in the registry key is linked to HKEY_LOCAL_MACHINE, so we can assume it will be here rather than the users registry hive.
C:\Temp\cc.exe
HKLM\Software\Microsoft\Windows\CurrentVersion\Run /v Malware

6- The purpose of this malware is to check if there is an active internet connection, if there is it will proceed to try and open the URL http://www.practicalmalwareanalysis.com/cc.htm using the User-Agent ‘Internet Explorer 7.5/pma’ and if it is successful, it will read in the first 0x200 (512) bytes into a buffer, if not it will terminate. From this buffer the characters ‘<!–’ are read, and if they don’t exists the error message “Error 2.3: Fail to get command\n” is printed. If these do exist, it will print the message “Success: Parsed command is %c\n”, where %c is the first character read from the HTML comment buffer.
Based on the parsed command between the letters a and e, the program will either:

Create a directory at C:\Temp if it doesn’t exist
Copy a file to C:\Temp\cc.exe, the file passed is lpExistingFileName which we know would be the program name
Delete the file located at C:\Temp\cc.exe if it exists
Create persistence using the subkey HKLM\Software\Microsoft\Windows\CurrentVersion\Run with the value ‘Malware’ pointing to C:\Temp\cc.exe
Sleep for 100,000 milliseconds (100 seconds)
Display the error message “Error 3.2: Not a valid command provided”

---

### Lab 6-4
#### Questions
1. What is the difference between the calls made from the main method in
Labs 6-3 and 6-4?
2. What new code construct has been added to main?
3. What is the difference between this lab’s parse HTML function and
those of the previous labs?
4. How long will this program run? (Assume that it is connected to the
Internet.)
5. Are there any new network-based indicators for this malware?
6. What is the purpose of this malware?

#### Solution
1- In Lab 6-3 the calls directly from the main method consist of:
sub_401000, sub_401040, sub_401271, sub_401130, Sleep
In Lab 6-4 the calls directly from the main method consist of:
sub_401000, sub_401040, sub_401150 (differs), sub_4012B5 (differs), Sleep
sub_401000 = Check for internet connection.
sub_401040 = HTML C2 parsing function. Note: in 06-04 the User-Agent has changed.
sub_401150 (differs) = Jump Table switch statement as previously identified in Lab 06-03 sub_401130 to control actions.
sub_4012B5 (differs) = printf as previously identified in Lab 06-03 sub_401271.
![Screenshot01](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/2865d01c-b135-411c-9afc-6a09bc50f726)
![Screenshot02](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/6654695d-40e1-4867-9078-bc509bc82452)
![Screenshot03](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/a414298d-b4a4-413b-8599-d5def9ab7ca2)
![Screenshot04](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/73a455b8-d9af-47f9-b2a6-9661bb0502e2)
![Screenshot05](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/c286943c-3514-43eb-9e42-a55133993c91)

2- It's for loop function that increaments a variable by 1 a time and will be compared against the value 5A0h in hex (1440).
![Screenshot06](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/08896454-4595-4b6e-8ab3-24700d149053)

3- It takes an argument as apparent with the reference to arg_0, and a new variable szAgent and szAgent is being populated with the formatted user agent value.
![Screenshot08](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/d70fc842-c923-4d8c-9998-0a589ec22b31)

4- The program will run for 1440 minutes (24 hours).
1440 * 60,000 milliseconds = 86,400,000 milliseconds.

5- Internet Explorer 7.50/pma%d
where %d is equivalent to var_C or in this case the number of minutes that have passed since the program started. This can be used to monitor how long it has been running for in each request.

6- The purpose of this malware is to check if there is an active internet connection, if there is it will proceed to try and open the URL http://www.practicalmalwareanalysis.com/cc.htm using the User-Agent ‘Internet Explorer 7.5/pma%d’ which is passed in from a looping incremental user variable (this is used to track how long the program has been running.
If it is successful, it will read in the first 0x200 (512) bytes into a buffer, if not it will terminate. From this buffer the characters ‘<!–’ are read, and if they don’t exists the error message “Error 2.3: Fail to get command\n” is printed.
If these do exist, it will print the message “Success: Parsed command is %c\n”, where %c is the first character read from the HTML comment buffer.

Based on the parsed command between the letters a and e, the program will either:

- 'a' -> Create a directory at C:\Temp if it doesn’t exist.
- 'b' -> Copy a file to C:\Temp\cc.exe, the file passed is lpExistingFileName which we know would be the program name.
- 'c' -> Delete the file located at C:\Temp\cc.exe if it exists.
- 'd' -> Create persistence using the subkey HKLM\Software\Microsoft\Windows\CurrentVersion\Run with the value ‘Malware’ pointing to C:\Temp\cc.exe.
- 'e' -> Sleep for 100,000 milliseconds (100 seconds).
- Finally, default case -> Display the error message “Error 3.2: Not a valid command provided”

Based on the incrementing variable this program will run for 24hours before terminating. By renaming these functions and viewing the main method flow chart, we can easily see the flow of this malware.

--------------------------------**This concludes CHAPTER 6**--------------------------------
## CHAPTER 7
### Lab 7-1
#### Questions
1. How does this program ensure that it continues running (achieves persistence)
when the computer is restarted?
2. Why does this program use a mutex?
3. What is a good host-based signature to use for detecting this program?
4. What is a good network-based signature for detecting this malware?
5. What is the purpose of this program?
6. When will this program finish executing?

#### Solution
1- By examining the main function of this program, we can see reference to a service name 'MalService', a call to the StartServiceCtrlDispatcherA(According to the MSDN documentation, this function is used by a program to implement a service)
within this sub_401040(which will be called after the call of StartServiceCtrlDispatcherA) we can see references to opening the Service Control Manager(SC Manager) and evidence of a service creation which will be used for persistence.
NOTE (May be useful):
There are various methods that malware can use to achieve persistence, such as modifying the registry, creating scheduled tasks, installing itself as a service, or using rootkits to hide its presence.
By using these methods, malware can ensure that it runs automatically when the system starts, runs periodically or runs constantly in the background.
Malware achieves persistence by modifying the registry keys in one of AutoStart Extention Points (ASEPs), There  are some of the registry keys that malware mostly achieves its persistence by editing the registry keys at the User Level:
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce
If the malware is able to gain admin privileges, it will infect some of the keys at admin/system-level privileges:
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
![1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/e7af99bd-efe3-4533-aa68-dc6c29cd59fc)
![1_](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/85ebcbcd-eff0-40fa-a4de-cb4319698ff8)

---

2- The program uses Mutex to ensure that only one copy of the program is running at a time.
Detailed Answer:
By calling sub_401040, we cann see that it calls the function OpenMutexA and this call is attempting to obtain a handle to the named mutex 'HGL345', If the call fails the program terminates, else it will create a Mutex with this name.
![2](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/aaeb57d9-85c8-4ce9-8bb9-4a7493421012)
![2_](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/25272b01-6732-4374-90f6-bb43756bd153)

---

3- Detection of this program can be done by checking any host for the hardcoded mutex ‘HGL345’ or by checking them for any service with the hardcoded name ‘MalService’

4- BY examining the looping function, we can see that it uses the User Agent "Internet Explorer 8.0" and communicates with the URL "http://www.malwareanalysisbook.com" which are network-based indicators which can be used to identify execution of this program.
![4](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/6fa7ebad-c588-47de-8a0b-57506587dcc6)

---

5- After creating a service for persistence, we can see that the program sets up a timer checking for when the year is (0x834h) 2100 in decimal or midnight on january 1st 2100, At this time it will create (0x14h) 20 threads and executed the subroutine pointed at StartAddress and this routine opens the URL http://www.malwareanalysisbook.com whichh leads us to beleive that this is DDoS program, which when multiple machines have this setup will cause a DDoS againist http://www.malwareanalysisbook.com.
![5](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/88cc05cd-0ca4-4f42-a215-c06c48d55f8a)
![5_](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/3c43d2f3-2ef1-46b4-b677-ef5549015198)
![5__](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/41ead1ae-8885-40a3-a231-2b03c0388449)

---

6- This program will never finish. It waits on a timer until 1st january 2100, and then creates 20 threads, each of which runs in an infinite loop and download www.malwareanalysisbook.com indefinitely.
![6](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/e11376cf-25c4-45ed-b538-f6f6918c35b9)

---

In summary, this malware uses mutexes to ensure that only one copy is running at a time, creates a service to ensure that it runs again when the system reboots, waits until January 1, 2100, and then continues to download www.malwareanalysisbook.com indefinitely.

---

### Lab 7-2
#### Questions
1. How does this program achieve persistence?
2. What is the purpose of this program?
3. When will this program finish executing?

#### Solution
1- When examining the program it shows no evidence or strings relating to creation of common persistence mechanisms such as run keys, scheduled tasks, services, or startup files. so, The program does not achieve persistence.
![1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/0f967e34-f3f0-4807-ac36-163f8cd9f5ad)

---

2- Taking a look at the program imports we can see COM-related functions such as CoCreateInstance and OleInitialize functions which are required in order to use COM functionality.
Next, we can try dynamic analysis by running the program, it opens Internet Explorer and displays an advertisement. so, There is no evidence of the program modifying the system or installing itself to execute when the computer is restarted.
Lets navigate to the Main method and take a look at the code:
The malware initializes COM and obtain a pointer to a COM object with OleInitialize at 0x401005 and CoCreateInstance at 0x401022, the COM object returned will be stored in ppv.
Now we nned to examine the InterfaceIdentifier(IID) and ClassIdentifier(CLSID) to determine what COM functionality is being used.
rclsid=0002DF01-0000-0000-C000-000000000046
riid=D30C1661-CDAF-11D0-8A3E-00C04FC9E26E
To determine which program will be called, we can check the registry for CLSID or search for the IID on the internet for any documentation, After searching we can see that the IID is for IWebBrowser2 and CLSID is for InternetExplorer.
Following the code we can see that EAX points to the location of the COM object then EDX points to the beginning of the COM object itself and the function at an offset of +0x2C from the object is called, and the offset 0x2C for the IWebBrowser2 interface is the Navigate function.
When Navigate is called, Internet Explorer navigates to the web address http://www.malwareanalysisbook.com/ad.html.
After the call to Navigate, there are a few cleanup functions and then the program ends.
![2](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/1aa47ff8-25da-40ea-8fd1-641e1281759c)
![2_](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/556f96d0-7a46-4424-a767-bd5c10362e07)
![2__](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/d29dfd02-7bc1-4a94-8db9-e0df269fc360)

---

3- It simply displays a one-time advertisement and ends.

---

### Lab 7-3
#### Questions
1. How does this program achieve persistence to ensure that it continues
running when the computer is restarted?
2. What are two good host-based signatures for this malware?
3. What is the purpose of this program?
4. How could you remove this malware once it is installed?

#### Solution
1- The program shows refernce to DLL and a Windows DLL of kernel32.dll,
![1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/c678261e-e716-4932-afde-1486ed234b57)

By examining the rest of the application we can see a different DLL named kerne132.dll and reference to the supplied Lab07-03.dll DLL being copied into a file named C:\Windows\System32
![1_](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/7fdf5746-46e1-4956-9425-960903287c73)

By looking inside the function call to sub_4011E0, within this we can see a statement that indicates files are being checked within C:\* which was passed to the program, By searching further within this function, we can see that a comparison occurs that checks if a file is a .exe, and if not a jump occurs.
![1__](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/c875e749-f488-4ae5-bed9-0437a1fa02a1)
![1___](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/3e17c683-6923-4f23-a1ab-fdcb4b1b0c5b)
![1____](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/59b44da4-5fdb-4565-b8ca-b4acfbd8e445)

Based on this we can infer that something the file system located at C:\ is being recursively checked for .exe files, and if one is found something occurs. By checking the function sub_4010A0 which runs if the jump is not performed, we can gather what occurs when an executable file is found. 3 key calls we find are CreateFile, CreateFileMapping, and MapViewOfFile. Based on this we can infer that exe file is mapped into memory and then can be modified by this program.
![1_____](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/17708791-b42c-4bf5-836b-d6288f91b9ce)

Looking further at the program we can see that it compares kernel32.dll to a location within the executable, and if it isnt found, it will jump and repeat the process. Where it is found it proceeds to copy a value referenced by dword_403010 over the top of it.
With this we can infer that the program searches for executables recursively within C:\, and when they’re found it will open them, and directly in memory modify the file to replace any instances of kernel32.dll with kerne132.dll for persistence. Based on this we can infer the program is a type of file infector and uses the copied kerne132.dll (Lab07-03.dll) for its main payload. A brief look into Lab07-03.dll confirms that this has some form of C2 function and is likely a malicious as i explained below in details.
![1______](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/2d537b98-95cc-4f75-ba4f-e6f494e301f7)
![1_______](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/b6d9fe90-5811-4252-b15f-5d784c7cfe2e)

---

Detailed Answer:
There are many interesting strings in exe file we can show them in Die or using strings command in cmd, we can see kerne132.dll, .exe, WARNING_THIS_WILL_DESTROY_YOUR_MACHINE, C:\Windows\System32\Kernel32.dll, C:\windows\system32\kerne132.dll, Kernel32., Lab07-03.dll and C:\*
The string kerne132.dll is clearly designed to look like kernel32.dll but replaces the l with a 1.
The string Lab07-03.dll tells us that the .exe may access the DLL for this lab in some way.
![1](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/89048ae4-1c1a-4c9c-99e1-519ced98bdca)

Lets examine the imports for Lab07-03.exe
The imports CreateFileA, CreateFileMappingA, and MapViewOfFile tell us that this program probably opens a file and maps it into memory. The FindFirstFileA and FindNextFileA combination tells us that the program probably searches directories and uses CopyFileA to copy files that it finds.
And the exe does not import Lab07-03.dll (or use any of thefunctions from the DLL) This behavior is suspect :"
![1_](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/de94efe7-8686-4549-9ddc-f4a897d3d4ff)

Taking a look at DLL for any interesting strings and imports and i found a few strings hello, 127.26.152.13(IPAddress), sleep and exec.
The most interesting string is an IP address, 127.26.152.13, that the malware might connect to.
![1__](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/7ebb3047-55d6-4206-b6b7-8543ae051912)

Looking at the imports of this DLL file we can see that the imports from ws2_32.dll contain all the functions necessary to send and receive data over a network. Also CreateProcess function, which tells us that this program may create another process.
![1___](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/eb5ec372-ae17-4bff-a5ab-efbdfff918d2)

Lets look at exports of DLL. Oddly, it has no exports !!
Now we can move to dynamic analysis, When running the executable, it exits quickly without much noticeable activity.
We could try to run DLL using rundll32 but because the DLL has no exports, that won’t work.
Unfortunately, basic dynamic analysis doesn’t tell us much, So lets perform analysis using IDA Pro.
Strarting with DLL because it's analyzing will be much easier than EXE file:
Lets look at the imports to get a quick view of the DLL’s functionality.
The call to library function malloc which allocates memory blocks.Following this are calls to OpenMutexA and CreateMutexA to ensure that only one copy of the malware is running at one time.
The other listed functions are needed to establish a connection with a remote socket, and to transmit and receive data. This function ends with calls to Sleep and CreateProcessA.
Now, we don’t know what data is sent or received or what process is being created but we can guess that the function that sends and receives data and creates processes is designed to receive command from a remote machine.
At this moment we need to know what data is being sent and received, checking the destination address of the connection, Before the connect call there is a call to inet_addr with fixed IPAddress 127.26.152.13 and port 0x50 which is port 80 that used for web traffic.
![1____](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/a4968789-0d3b-4c93-958b-deb3c74d721d)

Lets take a look at send function to see what data is being communicated, buf stores the data to be sent over the network and it represents the string "hello".
![1_____](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/99abc1b8-5037-4cc7-97a4-7f7d601b01cc)

Lets search to know what the command line is, our receive buffer starts at 0x1000 and command line at 0x0FFB, this is 5 bytes into our receive buffer, In this case, the data received from the remote server would be exec FullPathOfProgramToRun. When the malware receives the exec FullPathOfProgramToRun command string from the remote server, it will call CreateProcessA with FullPathOfProgramToRun.
This brings us to the end of this function and DLL. We now know that this DLL implements backdoor functionality that allows the attacker to launch an executable on the system by sending a response to a packet on port 80.
![1______](https://github.com/A8N0RMAL/Windows-Internals/assets/119806250/e0f28f17-2923-4fb9-92f0-80bb241fe240)

2- kerne132.dll on disk, and the presence of Mutex ‘SADFHUHF’ in DLL.

3- The program is a file infector that infects executables on the system to load a malicious remote access trojan that connects back to the IP 127.26.152[.]13. By examining Lab07-03.dll, we can conclude that this trojan takes either the command sleep, or exec, which is used to start a process of interest.

4- Due to the malware infecting every executable on disk it is very difficult to remove. Because it will be used by every process. Further if it is removed during deadbox analysis, it is likely the system will crash when booting due to no variant of kernel32.dll being present.
So u have to modify kerne132.dll to be the legitimate kernel32.dll, or even change the malware actions and recompile to instead modify all executables to point to the legitimate kernel32.dll instead of kerne132.dll, it may be easier to rebuild the system or restore from backup.

--------------------------------**This concludes CHAPTER 7**--------------------------------
## CHAPTER 9
### Lab 9-1
#### Questions
